<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LKY 只有原創內容的 Blog</title>
  
  
  <link href="https://mosdeo.github.io/atom.xml" rel="self"/>
  
  <link href="https://mosdeo.github.io/"/>
  <updated>2023-03-08T10:58:27.173Z</updated>
  <id>https://mosdeo.github.io/</id>
  
  <author>
    <name>Lin, Kao-Yuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 NumPy 向量化加速 Python：顏色過濾快 200 倍</title>
    <link href="https://mosdeo.github.io/2023/03/07/%E7%94%A8%20NumPy%20%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%20Python%EF%BC%9A%E9%A1%8F%E8%89%B2%E9%81%8E%E6%BF%BE%E5%BF%AB%20200%20%E5%80%8D/"/>
    <id>https://mosdeo.github.io/2023/03/07/%E7%94%A8%20NumPy%20%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%20Python%EF%BC%9A%E9%A1%8F%E8%89%B2%E9%81%8E%E6%BF%BE%E5%BF%AB%20200%20%E5%80%8D/</id>
    <published>2023-03-07T16:00:00.000Z</published>
    <updated>2023-03-08T10:58:27.173Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇已經介紹過用「Boolean array indexing」的技巧，快速過濾一維陣列。</p><p>這一篇我們要用顏色過濾的需求，來示範快速過濾三維陣列。</p><hr><p>需求：把圖片中的膚色去除，只留下其他顏色</p><h2 id="入門-for-loop-寫法，速度定義為-1x">入門 for loop 寫法，速度定義為 1x</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> NumPy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求：把圖片中的膚色去除，只留下其他顏色</span></span><br><span class="line"><span class="comment"># 注意：這份程式碼只是示範如何使用向量化，並不是在教學如何做膚色檢測，不要來跟我槓膚色檢測效果好壞</span></span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&quot;boys.jpg&quot;</span>)</span><br><span class="line">lower_skin = [<span class="number">0</span>, <span class="number">48</span>, <span class="number">80</span>]</span><br><span class="line">upper_skin = [<span class="number">18</span>, <span class="number">225</span>, <span class="number">255</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法1: 使用 for 迴圈 (最慢)</span></span><br><span class="line">img_forloop = img.copy()</span><br><span class="line">img_hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV) <span class="comment"># 轉換成 HSV</span></span><br><span class="line">h, s, v = img_hsv[:, :, <span class="number">0</span>], img_hsv[:, :, <span class="number">1</span>], img_hsv[:, :, <span class="number">2</span>] <span class="comment"># 分離出 H, S, V</span></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(img.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(img.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> h[i, j] &gt; lower_skin[<span class="number">0</span>] <span class="keyword">and</span> h[i, j] &lt; upper_skin[<span class="number">0</span>] <span class="keyword">and</span> \</span><br><span class="line">            s[i, j] &gt; lower_skin[<span class="number">1</span>] <span class="keyword">and</span> s[i, j] &lt; upper_skin[<span class="number">1</span>] <span class="keyword">and</span> \</span><br><span class="line">            v[i, j] &gt; lower_skin[<span class="number">2</span>] <span class="keyword">and</span> v[i, j] &lt; upper_skin[<span class="number">2</span>]:</span><br><span class="line">            img_forloop[i, j] = <span class="number">0</span></span><br><span class="line">elapsed_time_for_loop = time.time() - start_time</span><br><span class="line">print(<span class="string">&quot;Elapsed time for loop: %s seconds&quot;</span> % (elapsed_time_for_loop))</span><br></pre></td></tr></table></figure><p>輸出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elapsed time <span class="keyword">for</span> loop: 0.38222789764404297 seconds</span><br></pre></td></tr></table></figure><p>上面這個程式碼，就是一般初學者最直覺，用 for loop 寫出來的程式碼，但是效能很差，for 迴圈一次只能處理一個數，數據頻繁的進出往來 RAM 與 CPU，拖慢很多時間。</p><hr><h2 id="用-NumPy-向量化計算，速度-200x">用 NumPy 向量化計算，速度 200x</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法2: 使用 NumPy 向量化</span></span><br><span class="line"><span class="comment"># 以上重複部份程式碼省略</span></span><br><span class="line">img_vectorlize = img.copy()</span><br><span class="line">img_hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV) <span class="comment"># 轉換成 HSV</span></span><br><span class="line">h, s, v = img_hsv[:, :, <span class="number">0</span>], img_hsv[:, :, <span class="number">1</span>], img_hsv[:, :, <span class="number">2</span>] <span class="comment"># 分離出 H, S, V</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">skin_mask = np.bitwise_and.reduce([</span><br><span class="line">        h &gt; lower_skin[<span class="number">0</span>], h &lt; upper_skin[<span class="number">0</span>],</span><br><span class="line">        s &gt; lower_skin[<span class="number">1</span>], s &lt; upper_skin[<span class="number">1</span>],</span><br><span class="line">        v &gt; lower_skin[<span class="number">2</span>], v &lt; upper_skin[<span class="number">2</span>]</span><br><span class="line">    ])</span><br><span class="line">img_vectorlize[skin_mask] = <span class="number">0</span></span><br><span class="line">elapsed_time_vectorlize = time.time() - start_time</span><br><span class="line">print(<span class="string">&quot;Elapsed time vectorlize: %s seconds&quot;</span> % (elapsed_time_vectorlize))</span><br></pre></td></tr></table></figure><p>輸出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elapsed time vectorlize: 0.001753091812133789 seconds</span><br></pre></td></tr></table></figure><p>技巧上的大方向，跟上一篇是一樣的。</p><p>我們不逐一比較，而是先產生一個篩子，一個與樣本數量同樣長度的篩子，直接拿這個篩子去一次過濾所有樣本，只要一次！</p><p>只是這一次需求更加複雜。上只有一個條件，這一次有六個條件取交集，所以用 <code>np.bitwise_and.reduce()</code> 來產生篩子。</p><p>我用以下程式碼，給六個條件都產生與樣本數量同樣維度的篩子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    h &gt; lower_skin[<span class="number">0</span>], h &lt; upper_skin[<span class="number">0</span>],</span><br><span class="line">    s &gt; lower_skin[<span class="number">1</span>], s &lt; upper_skin[<span class="number">1</span>],</span><br><span class="line">    v &gt; lower_skin[<span class="number">2</span>], v &lt; upper_skin[<span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>把這六個篩子放進一個陣列。</p><p>為什麼用 <code>np.bitwise_and.reduce()</code>？</p><p>bitwise_and 就是取交集、reduce 就是把陣列裡面的元素做某種「化N合1」的運算。</p><p>所以這六個篩子就會化簡成一個，篩出所有符合條件的樣本。</p><p>最後可以用 <code>img_vectorlize[skin_mask] = 0</code> 一次對符合六個條件的樣本，改顏色。</p><p>在我完整的程式碼中，還用了 <code>np.array_equal()</code> 來驗證兩種方法的結果是否一樣。</p><hr><p>原圖：</p><p><img src="content/images/boys.jpg" alt="原圖"></p><p>膚色換黑色</p><p>![膚色換黑色](content/images/skin_to_black.jpg</p><p>膚色換綠色</p><p><img src="content/images/skin_to_green.jpg" alt="膚色換綠色"></p><hr><p>這篇文章主要是介紹了 NumPy 的向量化計算，用一個生活化簡單案例，來說明 NumPy 向量化計算的優點。</p><p>這篇文章的完整程式碼，可以在這裡找到：<a href="https://gist.github.com/mosdeo/5b0193bead09251f13e649f5cf6129da">https://gist.github.com/mosdeo/5b0193bead09251f13e649f5cf6129da</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇已經介紹過用「Boolean array indexing」的技巧，快速過濾一維陣列。&lt;/p&gt;
&lt;p&gt;這一篇我們要用顏色過濾的需求，來示範快速過濾三維陣列。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;需求：把圖片中的膚色去除，只留下其他顏色&lt;/p&gt;
&lt;h2 id=&quot;入門-for-loo</summary>
      
    
    
    
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
    <category term="筆記" scheme="https://mosdeo.github.io/tags/%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>用 NumPy 向量化加速 Python：從3千萬剩男中找出比我高 16 倍</title>
    <link href="https://mosdeo.github.io/2023/03/07/%E7%94%A8%20NumPy%20%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%20Python%EF%BC%9A%E5%BE%9E3%E5%8D%83%E8%90%AC%E5%89%A9%E7%94%B7%E4%B8%AD%E6%89%BE%E5%87%BA%E6%AF%94%E6%88%91%E9%AB%98%E8%AE%8A%E5%BF%AB%2016%20%E5%80%8D/"/>
    <id>https://mosdeo.github.io/2023/03/07/%E7%94%A8%20NumPy%20%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%20Python%EF%BC%9A%E5%BE%9E3%E5%8D%83%E8%90%AC%E5%89%A9%E7%94%B7%E4%B8%AD%E6%89%BE%E5%87%BA%E6%AF%94%E6%88%91%E9%AB%98%E8%AE%8A%E5%BF%AB%2016%20%E5%80%8D/</id>
    <published>2023-03-07T16:00:00.000Z</published>
    <updated>2023-03-08T08:11:04.875Z</updated>
    
    <content type="html"><![CDATA[<p>Python 簡單易用，可以很快速的驗證各種演算法。但是到了真的要實際應用時，Python 的毛病就會凸顯，往往就是慢！而且慢的很難受。</p><p>我也熟悉 Go 或 C# 這些靜態型別的語言，但是欠缺各式各樣方便好用的套件，難以快速的驗證各種演算法。</p><p>這篇文章我們來看看如何用 NumPy 來加速 Python 的效能，並且用一個簡單的例子來說明。</p><hr><p>本文要介紹的是 NumPy 當中一種叫做「Boolean array indexing」的技巧，官方文件的連結如下：</p><ul><li><a href="https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing">Boolean array indexing</a></li></ul><hr><p>需求: 找出身高大於 178 cm 的資料</p><h2 id="入門-for-loop-寫法，速度定義為-1x">入門 for loop 寫法，速度定義為 1x</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> NumPy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中國有 3000 萬剩男，所以我隨機產生 3000 萬個身高數據</span></span><br><span class="line">np.random.seed(<span class="number">0</span>) <span class="comment"># 固定隨機種子，讓每次執行的結果都一樣，方便大家比較</span></span><br><span class="line">heights = np.random.randint(<span class="number">150</span>, <span class="number">200</span>, <span class="number">30000000</span>) <span class="comment"># 上下界設定為 150~200 cm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求: 找出身高大於 178 cm 的資料</span></span><br><span class="line"><span class="comment"># 因為我的身高是 178 cm，所以我想抓出身高比我能吸引的女人的樣本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 for 迴圈 (最慢)</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">heights_above_178 = []</span><br><span class="line"><span class="keyword">for</span> height <span class="keyword">in</span> heights:</span><br><span class="line">    <span class="keyword">if</span> height &gt; <span class="number">178</span>:</span><br><span class="line">        heights_above_178.append(height)</span><br><span class="line">elapsed_time_for_loop = time.time() - start_time</span><br><span class="line">print(<span class="string">&quot;檢驗結果: 高於178的人數為 %s&quot;</span> % (<span class="built_in">len</span>(heights_above_178)))</span><br><span class="line">print(<span class="string">&quot;Elapsed time for loop:   %s seconds&quot;</span> % (elapsed_time_for_loop))</span><br></pre></td></tr></table></figure><p>輸出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">檢驗結果: 高於178的人數為 126011670</span><br><span class="line">Elapsed time <span class="keyword">for</span> loop:   44.088807344436646 seconds</span><br></pre></td></tr></table></figure><p>上面這個程式碼，就是一般初學者最直覺，用 for loop 寫出來的程式碼，但是效能很差，因為:</p><ul><li>Python 是動態型別，所以每次迴圈都要去判斷型別，並且要去做型別轉換。</li><li>而且 for 迴圈一次只能處理一個數，數據頻繁的進出往來 RAM 與 CPU，效能也很差。</li></ul><hr><h2 id="用-NumPy-向量化計算，速度-16x">用 NumPy 向量化計算，速度 16x</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用向量化 (最快)</span></span><br><span class="line"><span class="comment"># 以上重複部份程式碼省略</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">heights_above_178 = heights[heights &gt; <span class="number">178</span>]</span><br><span class="line">elapsed_time_vectorlize = time.time() - start_time</span><br><span class="line">print(<span class="string">&quot;檢驗結果: 高於178的人數為 %s&quot;</span> % (<span class="built_in">len</span>(heights_above_178)))</span><br><span class="line">print(<span class="string">&quot;Elapsed time vectorlize: %s seconds&quot;</span> % (elapsed_time_vectorlize))</span><br></pre></td></tr></table></figure><p>輸出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">檢驗結果: 高於178的人數為 126011670</span><br><span class="line">Elapsed time vectorlize: 2.701777935028076 seconds</span><br></pre></td></tr></table></figure><p>上面這個程式碼，直接把整個陣列的數值都拿出來比較，然後再把結果存回陣列，這樣就不用一個一個比較了，效能就會快很多。</p><p>這樣可能比較難懂，我寫個分解動作的範例，讓大家可以更清楚的理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is_above_178 = heights &gt; <span class="number">178</span></span><br><span class="line">print(is_above_178)</span><br><span class="line">heights_above_178 = heights[is_above_178]</span><br></pre></td></tr></table></figure><p>輸出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ True  True False ... False False  True]</span><br></pre></td></tr></table></figure><p>如果在 debug console 查看 <code>is_above_178</code>，會看到一個很長的陣列，裡面的值都是 True 或 False，代表每個數字是否大於 178。結果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array([ True,  True, False, ..., False, False,  True])</span><br><span class="line">special variables</span><br><span class="line">[0:30000000] : [True, True, False, False, False, True, False, False, False, True, False, False, False, False, ...]</span><br><span class="line">dtype: dtype(<span class="string">&#x27;bool&#x27;</span>)</span><br><span class="line">max: <span class="string">&#x27;ndarray too big, calculating max would slow down debugging&#x27;</span></span><br><span class="line">min: <span class="string">&#x27;ndarray too big, calculating min would slow down debugging&#x27;</span></span><br><span class="line">shape: (30000000,)</span><br><span class="line">size: 30000000</span><br></pre></td></tr></table></figure><p>所以真正的動作是：</p><ol><li>先取得一個 boolean 陣列，裡面的值都是 True 或 False，代表每個數字是否大於 178。</li><li>再用這個 boolean 陣列，去取得原本的陣列，只取出 True 的部分。</li></ol><p>我們不逐一比較，而是先產生一個篩子，一個與樣本數量同樣長度的篩子，直接拿這個篩子去一次過濾所有樣本，只要一次！</p><hr><p>從計算機原理講，為什麼快？</p><ul><li>因為 NumPy 是靜態型別，所以不用每次迴圈都去判斷型別，並且不用去做型別轉換。</li><li>一次處理多個數字，數據不用頻繁的進出 RAM 與 CPU，效能更好。</li></ul><p>當演算法被正確地向量化時，CPU 僅需一條指令完成這行程式碼，而不是對每個 i 進行獨立操作。理想情況下，any(result)操作將只發生於 CPU 內部而不用將數據傳回 RAM。</p><hr><p>這篇文章主要是介紹了 NumPy 的向量化計算，用一個生活化簡單案例，來說明 NumPy 向量化計算的優點。</p><p>這篇文章的完整程式碼，可以在這裡找到：<a href="https://gist.github.com/mosdeo/341216a87a099486c1420760f24ced00">https://gist.github.com/mosdeo/341216a87a099486c1420760f24ced00</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python 簡單易用，可以很快速的驗證各種演算法。但是到了真的要實際應用時，Python 的毛病就會凸顯，往往就是慢！而且慢的很難受。&lt;/p&gt;
&lt;p&gt;我也熟悉 Go 或 C# 這些靜態型別的語言，但是欠缺各式各樣方便好用的套件，難以快速的驗證各種演算法。&lt;/p&gt;
&lt;p&gt;這</summary>
      
    
    
    
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
    <category term="筆記" scheme="https://mosdeo.github.io/tags/%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>用 NumPy 向量化加速 Python：千萬級矩形面積計算變快 16~177 倍</title>
    <link href="https://mosdeo.github.io/2023/03/04/%E7%94%A8%20NumPy%20%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%20Python%EF%BC%9A%E5%8D%83%E8%90%AC%E7%B4%9A%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A9%8D%E8%A8%88%E7%AE%97%E8%AE%8A%E5%BF%AB%2016~177%20%E5%80%8D/"/>
    <id>https://mosdeo.github.io/2023/03/04/%E7%94%A8%20NumPy%20%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%20Python%EF%BC%9A%E5%8D%83%E8%90%AC%E7%B4%9A%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A9%8D%E8%A8%88%E7%AE%97%E8%AE%8A%E5%BF%AB%2016~177%20%E5%80%8D/</id>
    <published>2023-03-04T16:00:00.000Z</published>
    <updated>2023-03-07T01:19:37.918Z</updated>
    
    <content type="html"><![CDATA[<p>Python 簡單易用，可以很快速的驗證各種演算法。但是到了真的要實際應用時，Python 的毛病就會凸顯，往往就是慢！而且慢的很難受。</p><p>我也熟悉 Go 或 C# 這些靜態型別的語言，但是欠缺各式各樣方便好用的套件，難以快速的驗證各種演算法。</p><p>這篇文章我們來看看如何用 NumPy 來加速 Python 的效能，並且用一個簡單的例子來說明。</p><p>需求是：計算 1780 萬個矩形的面積</p><h2 id="入門的人怎麼寫？速度定義為-1x">入門的人怎麼寫？速度定義為 1x</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> NumPy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隨機產生 1780 萬個矩形的兩個對角點座標，為什麼用這個數字呢？因為178是我的身高</span></span><br><span class="line">np.random.seed(<span class="number">0</span>) <span class="comment"># 固定隨機種子，讓每次執行的結果都一樣，方便大家比較</span></span><br><span class="line">rects = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, (<span class="number">17800000</span>, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算這些矩形的面積，使用 for 迴圈</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">area = []</span><br><span class="line"><span class="keyword">for</span> rect <span class="keyword">in</span> rects:</span><br><span class="line">    area.append((<span class="built_in">abs</span>(rect[<span class="number">0</span>][<span class="number">0</span>] - rect[<span class="number">0</span>][<span class="number">1</span>]) * <span class="built_in">abs</span>(rect[<span class="number">1</span>][<span class="number">0</span>] - rect[<span class="number">1</span>][<span class="number">1</span>])))</span><br><span class="line">elapsed_time_for_loop = time.time() - start_time</span><br><span class="line">print(<span class="string">&quot;檢驗結果: %s&quot;</span> % (<span class="built_in">sum</span>(area)))</span><br><span class="line">print(<span class="string">&quot;Elapsed time: %s&quot;</span> % (elapsed_time_for_loop))</span><br></pre></td></tr></table></figure><p>輸出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">檢驗結果: 19769742257</span><br><span class="line">Elapsed time: 16.575732946395874</span><br></pre></td></tr></table></figure><p>上面這個程式碼，就是一般初學者最直覺，用 for loop 寫出來的程式碼，但是效能很差，因為:</p><ul><li>Python 是動態型別，所以每次迴圈都要去判斷型別，並且要去做型別轉換。</li><li>而且 for 迴圈一次只能處理一個矩形，數據頻繁的進出往來 RAM 與 CPU，效能也很差。</li></ul><hr><h2 id="用-NumPy-向量化計算-簡單版-，速度-16x">用 NumPy 向量化計算(簡單版)，速度 16x</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> NumPy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隨機產生 1780 萬個矩形的兩個對角點座標，為什麼用這個數字呢？因為178是我的身高</span></span><br><span class="line">rects = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, (<span class="number">17800000</span>, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算這些矩形的面積，使用最簡單的向量化</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">min_x = np.<span class="built_in">min</span>(rects[:, <span class="number">0</span>], axis=<span class="number">1</span>)</span><br><span class="line">max_x = np.<span class="built_in">max</span>(rects[:, <span class="number">0</span>], axis=<span class="number">1</span>)</span><br><span class="line">min_y = np.<span class="built_in">min</span>(rects[:, <span class="number">1</span>], axis=<span class="number">1</span>)</span><br><span class="line">max_y = np.<span class="built_in">max</span>(rects[:, <span class="number">1</span>], axis=<span class="number">1</span>)</span><br><span class="line">area = (max_x - min_x) * (max_y - min_y)</span><br><span class="line">elapsed_time_vectorlize = time.time() - start_time</span><br><span class="line">print(<span class="string">&quot;檢驗結果: %s&quot;</span> % (<span class="built_in">sum</span>(area)))</span><br><span class="line">print(<span class="string">&quot;Elapsed time: %s&quot;</span> % (elapsed_time_vectorlize))</span><br></pre></td></tr></table></figure><p>輸出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">檢驗結果: 19769742257</span><br><span class="line">Elapsed time: 1.0222868919372559</span><br></pre></td></tr></table></figure><p>上面這個程式碼，直接把矩形的兩個對角點座標的XY值，分別按照大小取出來，成為四個 Nx1 矩陣。然後只做1次矩陣化的面積運算，就算完了 N 個矩形的面積，效能提升了 16 倍。</p><p>為什麼快？</p><ul><li>因為 NumPy 是靜態型別，所以不用每次迴圈都去判斷型別，並且不用去做型別轉換。</li><li>一次處理多個矩形，數據不用頻繁的進出 RAM 與 CPU，效能更好。</li></ul><p>當演算法被正確地向量化時，CPU 僅需一條指令完成這行程式碼，而不是對每個 i 進行獨立操作。理想情況下，any(result)操作將只發生於 CPU 內部而不用將數據傳回 RAM。</p><hr><h2 id="用-NumPy-向量化計算-進階版，使用np-ptp-，速度-22x">用 NumPy 向量化計算(進階版，使用np.ptp)，速度 22x</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以上重複部份程式碼省略</span></span><br><span class="line"><span class="comment"># 計算這些矩形的面積，使用np.ptp向量化</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">area = np.ptp(rects[:, <span class="number">0</span>], axis=<span class="number">1</span>) * np.ptp(rects[:, <span class="number">1</span>], axis=<span class="number">1</span>)</span><br><span class="line">elapsed_time_ptp = time.time() - start_time</span><br><span class="line">print(<span class="string">&quot;檢驗結果: %s&quot;</span> % (<span class="built_in">sum</span>(area)))</span><br><span class="line">print(<span class="string">&quot;Elapsed time: %s&quot;</span> % (elapsed_time_ptp))</span><br></pre></td></tr></table></figure><p>輸出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">檢驗結果: 19769742257</span><br><span class="line">Elapsed time: 0.7305142879486084</span><br></pre></td></tr></table></figure><p>上面這個程式碼，就是用 NumPy 向量化計算的方式，效能提升了 22 倍。<br>為什麼又更快？</p><p>因為 np.ptp 的意思就是「peak to peak」，把「最大值、最小值、取差值」的計算合併成一個函式，所以效能更好。</p><hr><h2 id="用-NumPy-向量化計算-進階版，直接取差值，然後絕對值相乘-，速度-177x">用 NumPy 向量化計算(進階版，直接取差值，然後絕對值相乘)，速度 177x</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以上重複部份程式碼省略</span></span><br><span class="line"><span class="comment"># 計算這些矩形的面積，直接取絕對值相乘</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">area = np.<span class="built_in">abs</span>(rects[:, <span class="number">0</span>, <span class="number">0</span>] - rects[:, <span class="number">0</span>, <span class="number">1</span>]) * np.<span class="built_in">abs</span>(rects[:, <span class="number">1</span>, <span class="number">0</span>] - rects[:, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 下面這種方法更快一點，但可能會發生 Exception has occurred: _ArrayMemoryError</span></span><br><span class="line"><span class="comment"># area = np.abs(np.diff(rects[:, 0], axis=1)) * np.abs(np.diff(rects[:, 1], axis=1)).flatten()</span></span><br><span class="line">elapsed_time_diff_abs = time.time() - start_time</span><br><span class="line">print(<span class="string">&quot;檢驗結果: %s&quot;</span> % (<span class="built_in">sum</span>(area)))</span><br><span class="line">print(<span class="string">&quot;Elapsed time: %s&quot;</span> % (elapsed_time_diff_abs))</span><br></pre></td></tr></table></figure><p>輸出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">檢驗結果: 19769742257</span><br><span class="line">Elapsed time: 0.09360003471374512</span><br></pre></td></tr></table></figure><p>上面這個程式碼，就是用 NumPy 向量化計算的方式，效能提升了 177 倍。</p><p>為什麼又更快？</p><p>老實說，到這裡已經到了我的知識盲區了。</p><p>不論是 slicing 或者進出 RAM 與 CPU 的次數，與前一種方法看起來都一樣，但是效能卻可以從 22 倍提升到 177 倍。我猜測可能是因為 np.ptp 有些限制導致速度比較慢。</p><p>用 NumPy 就是這樣，通常會比只用單純的 Python 快很多，但是各種不同用法的效能差異卻很大。</p><p>想達到最好的效能，有沒有一次到位的方法？除非有時間仔細鑽研 NumPy 的底層原理，不然我覺得沒有，只能一步一步的嘗試，並且不斷的優化。</p><h2 id="更快的方法，要注意其他的風險">更快的方法，要注意其他的風險</h2><p>可以看到，在最後一段程式碼中，有一行被我註解的地方。</p><p>用 np.diff 也可以達到同樣的效果，還更快一點，而且我完全想不出原因是什麼？</p><p>但是我開了 Docker 之後，就會發生爆記憶體的錯誤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception has occurred: _ArrayMemoryError</span><br><span class="line">Unable to allocate 2.25 PiB <span class="keyword">for</span> an array with shape (17800000, 17800000) and data <span class="built_in">type</span> int64</span><br><span class="line">  File <span class="string">&quot;/Users/xxx/demo_vectorlize.py&quot;</span>, line 44, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    area = np.abs(np.diff(rects[:, 0], axis=1)) * np.abs(np.diff(rects[:, 1], axis=1)).flatten()</span><br><span class="line">           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">numpy.core._exceptions._ArrayMemoryError: Unable to allocate 2.25 PiB <span class="keyword">for</span> an array with shape (17800000, 17800000) and data <span class="built_in">type</span> int64</span><br></pre></td></tr></table></figure><p>可以看到 np.diff 跟記憶體要了一塊 N x N 的空間，而 N 高達 17800000，這對許多系統來說是無法承受的。而且你開發時可能不會出現這個問題，但是到了生產環境才發現，那就踩了大坑了。</p><h2 id="總結">總結</h2><p>三種向量化計算的效能，與原本的 for-loop 效能比較如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Speed up <span class="keyword">for</span> vectorlize: 16.214365142630854x</span><br><span class="line">Speed up <span class="keyword">for</span> ptp-vectorlize: 22.690497940763034x</span><br><span class="line">Speed up <span class="keyword">for</span> diff-abs-vectorlize: 177.09109827885285x</span><br></pre></td></tr></table></figure><p>這篇文章主要是介紹了 NumPy 的向量化計算，用一個工作上實際遇過的簡單案例，來說明 NumPy 向量化計算的優點。</p><p>這篇文章的程式碼，可以在這裡找到：<a href="https://gist.github.com/mosdeo/743a6e2275ea7676dc2f98246e055b33">https://gist.github.com/mosdeo/743a6e2275ea7676dc2f98246e055b33</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python 簡單易用，可以很快速的驗證各種演算法。但是到了真的要實際應用時，Python 的毛病就會凸顯，往往就是慢！而且慢的很難受。&lt;/p&gt;
&lt;p&gt;我也熟悉 Go 或 C# 這些靜態型別的語言，但是欠缺各式各樣方便好用的套件，難以快速的驗證各種演算法。&lt;/p&gt;
&lt;p&gt;這</summary>
      
    
    
    
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
    <category term="筆記" scheme="https://mosdeo.github.io/tags/%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>中國大陸 Apple Trade In 過程全記錄，委託第三方的服務果然翻車</title>
    <link href="https://mosdeo.github.io/2021/08/03/AppleTrade-in%E9%81%8E%E7%A8%8B/"/>
    <id>https://mosdeo.github.io/2021/08/03/AppleTrade-in%E9%81%8E%E7%A8%8B/</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-08-04T05:54:50.863Z</updated>
    
    <content type="html"><![CDATA[<h1>換 Apple Silicon，出清 Intel</h1><p>由於買了新的 M1 MacBook Air，做完數據移轉、相容性驗證之後，舊的 Intel MacBook Air 就「食之無味、棄之可惜」了。</p><p>算一算賣給蘋果官方還有 3000 元可以拿！於是就開啟了人生第一次 Apple Trade In。</p><p><img src="/content/images/apple_trade_in/IMG_8498.jpg" alt="新舊Mac之間正在使用TB3線數據移轉"></p><hr><h1>這輩子換過這麼多電腦，為什麼這是第一次 trade-in？</h1><p>要是還在台灣，處理舊機的首選通常是上 PTT 或蝦皮賣掉，自己搓合賣家，能拿到比較好的價錢。例如我的 Intel MacBook 當初就是在 PTT 上買到的；確認可用以後，又在蝦皮上把 ThinkPad 賣掉。</p><p>但中國大陸有特殊的民情，自己上閒魚等平台找買家，過程非常耗時耗力噁心人，所以第三方收二手機的情況很發達，願意買二手機的情況也比台灣少很多，甚至買二手機被認為是丟臉的事。</p><hr><h1>申請 Apple Trade In</h1><p>線上申請完以後，就會看到如下畫面：</p><p><img src="/content/images/apple_trade_in/apple_trade_in_apply_done.jpg" alt=""></p><p>好尷尬啊，台灣人沒有中國大陸身份證，不知道 Apple 會怎麼處理？</p><p>當天就會收到這個簡訊：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【爱锋派】Apple Trade In 换购计划 - </span><br><span class="line">尊敬的客户，欢迎您在 Apple 官网参与 Apple Trade In 换购计划。</span><br><span class="line">您的折抵编号为2125XXXX。</span><br><span class="line">请访问 http://portal-blit.ifengpai.com/portal/v1/schedule/EGPXXXX 预约承运商上门收取折抵设备的时间, 或者取消折抵换购</span><br></pre></td></tr></table></figure><p>點連結進去，挑選收件時間。</p><p>收件前一天還會收到這個提醒簡訊：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【爱锋派】Apple Trade In 换购计划 - </span><br><span class="line">尊敬的客户，感谢您在Apple官网参与 Apple Trade In 换购计划。</span><br><span class="line">您的折抵编号为2125XXXX。您预约上门取件的时间是2021-07-27。</span><br><span class="line">如果您想更改上门取件时间，请在今晚12点前访问 http://portal-blit.ifengpai.com/portal/v1/schedule/XYGXXXX 并选择新的取件时间。</span><br><span class="line">根据《邮件快件实名收寄管理办法》，取件时请准备好有效身份证件以供承运商查验。</span><br><span class="line">如果您的地址超出承运商服务范围，我们将及时与您联系。</span><br></pre></td></tr></table></figure><p>收件當天早上還會收到這個提醒簡訊：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【顺丰速运】顺丰小哥1326830XXXX正上门收件，运单尾号3853，验证码1808。谢谢！</span><br></pre></td></tr></table></figure><p>整個過程的提醒，都相當貼心到位。</p><hr><h1>交機給順豐小哥</h1><p><img src="/content/images/apple_trade_in/IMG_8519.jpg" alt=""></p><h1>在 FindMy 上目送我的筆電最後一程</h1><p>交機前，我先刪除一些敏感數據、登出服務，但是我故意沒有登出 Apple ID、關閉 Find My，我想看能不能在路上追蹤到？因為蘋果裝置本身就如同一個 AirTag，感覺會挺好玩的。</p><p>果然，當天下午就一路從廣州移動到深圳寶安區。</p><p><img src="/content/images/apple_trade_in/mac_ontheway_banao_2.png" alt=""></p><p>隔天早上出現在鄭州。</p><p><img src="/content/images/apple_trade_in/mac_ontheway_zhengzhou.jpg" alt=""></p><p>但中間會有很長的間斷，我猜可能是這樣：</p><ul><li>送貨車廂為金屬外殼，所以遮蔽了 WiFi 與藍牙訊號。</li><li>在高速公路、郊區等路段，路上距離別的車比較遠，送貨小哥自己又不是用 iPhone，所以就長時間沒辦法連線定位。</li><li>偶爾在中途收件、轉運的時候，貨物可以暴露在 iDeviec 的訊號之下，就能把位置傳回來我手中。</li></ul><h1>工廠打電話來要機器登入密碼</h1><p>這也算是有點在我預期中的，所以我就把密碼告訴他們，然後在 Find My 上執行清除數據。並且在大約一個小時後顯示清除完成（只是顯示，後面會詳述）。</p><p><img src="/content/images/apple_trade_in/IMG_8539.PNG" alt=""><br><img src="/content/images/apple_trade_in/IMG_8540.PNG" alt=""></p><p>沒想到，事情並不如我想得這麼順利。</p><h1>工廠又反覆打電話來，說我沒有清除數據，多次要求我重做</h1><p>第二天，是一個操北方口音的女人打電話來，要我執行清除數據，我說：<br>「昨天下午就做過了啊！你們打來要密碼之後我就主動清除了。」<br>「你們有聯網嗎？是不是沒有聯網？」<br>她表示不太清楚狀況，會轉告工廠。</p><p>第三天，是一個男人打電話來，聽起來應該是第一線執行的員工，又說我沒有清除數據，並且為了證明，說可以登入我的電腦，看到哪些數據等等（我不太擔心，敏感數據交付順豐之前都已經刪除）。</p><p>我再次確認，他說已經聯網。</p><p>這一次，我半信半疑的拿出手機照做，看到畫面上顯示這台電腦的狀態是「Erased now」（如下圖），而且我沒辦法再做更多操控的動作，只能看到這台電腦的「電量、是否充電中、位置」。至於「電量、是否充電中、位置」，是不是暫存的歷史訊息？我跟電話中的小哥核對後，都與現況相符，巧合的機率不高，應該是即時訊息。</p><p><img src="/content/images/apple_trade_in/IMG_3093.PNG" alt=""></p><p>也就是說，透過 Find My 清除自己電腦中的數據後，唯一能掌握的訊息應該就是「電量、是否充電中、位置」。</p><p>我把狀況轉告給電話中的小哥，他又做出以下要求：</p><p>「你還有其他蘋果裝置嗎？」<br>「其他蘋果裝置也顯示已抹除嗎？」<br>「你用瀏覽器登入 iCloud 看看，是不是也已清除？」</p><p>此時，我已經非常的不耐煩，但是怕 trade-in 失敗造成更多麻煩，只好先照做。</p><p>我用不同的裝置在瀏覽器上登入 iCloud（如下圖），結果也是一樣，已經清除過，不能再清除。只多了「播放聲音」的功能。</p><p><img src="/content/images/apple_trade_in/IMG_3083.PNG" alt=""></p><p>我反覆描述這個狀況後，電話另一端的小哥才放棄，說再看看怎麼辦。</p><p>第三天，是一個週六早上，我正在外頭忙，他們又打電話來。這次電話中又是不同人，似乎把狀況搞得比較清楚了，說我之前做的那些動作需要「電腦當下聯網」才會生效，請我重新做一次。（難道前幾次電話處理，都不是當下聯網？）</p><p>這次我又不耐煩地拿出平板打開 Find My，終於有點「新東西」了！顯示出在鄭州工廠的那台電腦，並且是未清除的狀態，可以進行所有常規操作。</p><p>這一次清除，電話中的小哥立刻就說有在清除了。但我在忙、可能也沒耐心了，沒把之前的清除訊息再打一次。之後就按照指示把電腦從 Find My 中移除。</p><p>到這邊，麻煩的溝通才算告一段落。</p><h1>收到確認簡訊、上傳證件、錢到帳</h1><p>接下來幾天就陸續收到這些簡訊。</p><p>週日下午3點：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【爱锋派】Apple Trade In 换购计划 - </span><br><span class="line">尊敬的客户，我们已收到您的设备。</span><br><span class="line">我们的团队对设备进行检测后，会再次联系您。</span><br><span class="line">如有问题，您可以联系爱锋派客服热线：4008210742。</span><br></pre></td></tr></table></figure><p>週日下午5點：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【爱锋派】Apple Trade In 换购计划 - </span><br><span class="line">尊敬的客户，我们对MacBook Air进行检测后，确认评估价值与人民币3000.0元的初始估价一致。</span><br><span class="line">根据国家相关部门的规定，请在这里上传您的二代身份证正反面照片，审核照片后，我们将在 2 个工作日内给您付款。</span><br><span class="line">地址: https://reuserecycle.ifengpai.com/order/statusQuery 如有问题，您可以联系爱锋派客服热线：4008210742。</span><br></pre></td></tr></table></figure><p>幸好上傳沒有阻擋台胞證，有跳出視窗說是人工審核，要等。</p><p><img src="/content/images/apple_trade_in/upload_credentials.png" alt=""></p><p>週一下午5點：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【爱锋派】Apple Trade In 换购计划 - </span><br><span class="line">尊敬的客户，我们已经给您付款，付款金额为人民币 3000.0 元。</span><br><span class="line">感谢您选择爱锋派进行Apple Trade In 换购计划。</span><br><span class="line">如有问题，您可以联系爱锋派客服热线：4008210742</span><br></pre></td></tr></table></figure><p><img src="/content/images/apple_trade_in/received3000.jpg" alt=""></p><h1>結語1：電話通知清除與移除的過程，極不專業，帶給用戶很多麻煩</h1><p>這部分過程都寫了，就不再詳述。</p><p>畢竟回收舊機器還是比較髒的事，原廠摸透流程後，大多就會包給第三方做，就難免有這些小缺點。</p><h1>結語2：作為台灣人特別需要噴 Apple 有缺失的地方</h1><p>整個流程都說要「二代身份证」，這對於在中國大陸各種日常生活系統上，經常因為證件不符，習慣被拒絕使用的台灣人來說，是特別不友善的用詞。</p><p>真的考慮的夠，就不會寫「上传您的二代身份证正反面照片」，因為在字面上已經排除收其他證件的可能。應該寫「有效身分證件」。</p><p>都寫了要「二代身份证」還拿台胞證硬闖，我在中國大陸生活兩年多，這是第一次成功！一般遇到這種情況，我都會基於成功率太低的經驗放棄，這次是憑著對蘋果的信任，還有果粉朋友的話，才硬著頭皮把流程走到底。</p><p>果粉朋友的話是這麼說的：</p><blockquote><p>那放心，水果对第三方要求很高，会考虑到港台中国居民<br>只有 sb 私企才不考虑港澳台的中国居民，你又懒得投诉<br>所以转人工审核了，我不信他们只收内地身份证的</p></blockquote><p>（我也不確定，是不是這樣才轉人工審核？或許不論什麼證件都人工審核？）</p><p>換句話說，蘋果只寫了收「二代身份证」，卻還讓台胞證硬闖成功，也是變相鼓勵在中國大陸生活卻沒有「二代身份证」的人，不去遵守字面上的系統規範，鼓勵試探規則底限與漏洞，這種作風非常的不蘋果，也不是高端品牌應該有的作法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;換 Apple Silicon，出清 Intel&lt;/h1&gt;
&lt;p&gt;由於買了新的 M1 MacBook Air，做完數據移轉、相容性驗證之後，舊的 Intel MacBook Air 就「食之無味、棄之可惜」了。&lt;/p&gt;
&lt;p&gt;算一算賣給蘋果官方還有 3000 元可以拿！於</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何在 Apple Silicon 上安裝 OpenCV 4.5.3 與 TensorFlow 2.5 給 Python 用？</title>
    <link href="https://mosdeo.github.io/2021/07/25/%E5%A6%82%E4%BD%95%E5%9C%A8Apple%20Silicon%E4%B8%8A%E5%AE%89%E8%A3%9DOpenCV%E8%88%87TensorFlow%E7%B5%A6Python%E7%94%A8%EF%BC%9F/"/>
    <id>https://mosdeo.github.io/2021/07/25/%E5%A6%82%E4%BD%95%E5%9C%A8Apple%20Silicon%E4%B8%8A%E5%AE%89%E8%A3%9DOpenCV%E8%88%87TensorFlow%E7%B5%A6Python%E7%94%A8%EF%BC%9F/</id>
    <published>2021-07-25T16:00:00.000Z</published>
    <updated>2021-07-28T07:00:49.106Z</updated>
    
    <content type="html"><![CDATA[<p>我來證明 Apple Silicon 現在也可以煉丹了！</p><p><img src="/content/images/install_opencv_and_tensorflow_for_python_on_applesilicon/about_the_mac.png" alt=""></p><p>下圖是筆者在 Apple Silicon 上跑起了 OpenCV 4.5.3 與 TensorFlow 2.5.0。</p><p><img src="/content/images/install_opencv_and_tensorflow_for_python_on_applesilicon/run_in_terminal.png" alt=""></p><p>在朋友推坑之下，筆者入手了 Apple Silicon (以下簡稱M1) MacBook。</p><p>這兩天做完相容性驗證之後，準備把舊的 Intel MacBook 賣掉。</p><p><img src="/content/images/install_opencv_and_tensorflow_for_python_on_applesilicon/apple_trade_in_apply_done.jpg" alt=""></p><p>（好尷尬啊，台灣人沒有中國大陸身份證，不知道 Apple 會怎麼處理？）</p><hr><p>相容性驗證有哪些項目？主要驗證我常用的 OpenCV、scikit、numpy、TensorFlow 等套件如何安裝？能不能正常跑？</p><p>經過大量苦逼無聊的工作後，發現目前還是不能常規無痛安裝，必須以 workaround 的手段安裝。</p><h2 id="坑有哪些？">坑有哪些？</h2><ul><li>目前網上充斥各種過時、有錯誤的野生安裝方法。</li><li>就算最多人參考的<a href="https://sayak.dev/install-opencv-m1/">國外大神帖子</a>，也有過時或出錯的地方，造成安裝完全失敗。</li></ul><p>經過我徹夜摸索後，修正國外大神帖子中部分問題，終於跑通一套可以正確安裝 OpenCV 當下最新版（4.5.3）與 TensorFlow 2.5.0（僅限 Apple 分支） 的流程。</p><p>以從頭乾淨安裝來說，目前各種 Python 的數據科學 package 幾乎只能走 conda 安裝，疑似還是要依賴 Rostta2？這部分我就不懂，有請熟悉編譯器或虛擬機器的大神補充。</p><h2 id="Step-0-安裝-Xcode-與-brew">Step 0: 安裝 Xcode 與 brew</h2><p>這步驟我覺得對 macOS 上的開發者來說是必備且熟練了，所以懶得寫。</p><p>記得 brew 要安裝 Apple Silicon 用的版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> brew</span><br><span class="line">/opt/homebrew/bin/brew</span><br></pre></td></tr></table></figure><p>Apple Silicon 用的 brew 版本，路徑是 opt 開頭的。</p><h2 id="Step-1-安裝-Conda">Step 1: 安裝 Conda</h2><p>這個連結，下載並執行：</p><p><a href="https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-MacOSX-arm64.sh">https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-MacOSX-arm64.sh</a></p><p>這裡就會包含有針對 Apple Silicon 最佳化的 Python 3.9，也一併安裝。</p><hr><p>我沒有要做環境隔離，所以直接 <code>conda activate</code> 進入到名為 base 的 conda env。</p><p>你嘗試下圖的指令，看是不是跟我一樣？</p><p><img src="/content/images/install_opencv_and_tensorflow_for_python_on_applesilicon/conda_switch.png" alt=""></p><p>這代表成功切換虛擬環境，並用上 Python 3.9</p><h2 id="Step-2-安裝-Numpy（in-tensorflow-deps）">Step 2: 安裝 Numpy（in tensorflow-deps）</h2><h3 id="小心有坑！">小心有坑！</h3><p>按照國外大神提供的步驟，在這一步就出錯，走不下去，原因是內容有些過時了。</p><p>你照做就會看到以下的錯誤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ (base) ➜ pip install --upgrade --no-dependencies --force numpy-1.18.5-cp38-cp38-macosx_11_0_arm64.whl</span><br><span class="line"></span><br><span class="line">ERROR: numpy-1.18.5-cp38-cp38-macosx_11_0_arm64.whl is not a supported wheel on this platform.</span><br></pre></td></tr></table></figure><p>原因：這個 numpy 包的「cp38」代表是給 Python 3.8，版本號多或少一點都不行！可是最多也只出到 3.8，但指定的 conda 環境已經變成 Python 3.9，而且為了 M1 優化也是從 Python 3.9 開始，所以這邊就衝突了。那這個坑怎麼辦呢？</p><h3 id="我已出坑">我已出坑</h3><p>不論只安裝 OpenCV 與 TensorFlow 其中哪一個，這一步都是必要的前置步驟。</p><p>這邊直接安裝 Apple 官方提供的 tensorflow-deps，會聯同 numpy 一起搞定。上面單獨安裝一個 .whl 的步驟就不用了。</p><p><code>conda install -c apple tensorflow-deps</code></p><p>安裝完以後測試看看，有 numpy 版本號出現就是可以了。</p><p><code>python -c &quot;import numpy as np;print(np.__version__)&quot;</code></p><p><img src="/content/images/install_opencv_and_tensorflow_for_python_on_applesilicon/numpy_import_test.png" alt=""></p><h2 id="Step-3-編譯-OpenCV">Step 3: 編譯 OpenCV</h2><p>通常說到編譯，就會想到等很久。還好我們用的是 Apple Silicon，所以這次很快，我記得開始編譯之後就去洗澡，洗完出來剛好完成。</p><p>在家目錄下載 OpenCV 與他的延伸套件、解壓縮、進入編譯資料夾。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /Library/OpenCV &amp;&amp; <span class="built_in">cd</span> /Library/OpenCV</span><br><span class="line">wget -O opencv.zip https://github.com/opencv/opencv/archive/4.5.3.zip</span><br><span class="line">wget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/4.5.3.zip</span><br><span class="line">unzip opencv.zip</span><br><span class="line">unzip opencv_contrib.zip</span><br><span class="line">mv opencv.zip opencv_contrib.zip ~/Downloads</span><br><span class="line"><span class="built_in">cd</span> opencv-4.5.3</span><br><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><p>然後 cmake</p><h3 id="小心有坑！-v2">小心有坑！</h3><p>外國大神提供的指令這邊有錯，照做會得到這個錯誤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Make Error: The <span class="built_in">source</span> directory <span class="string">&quot;/Library/OpenCV/opencv-4.5.3/_&quot;</span> does not exist.</span><br><span class="line">Specify --<span class="built_in">help</span> <span class="keyword">for</span> usage, or press the <span class="built_in">help</span> button on the CMake GUI.</span><br></pre></td></tr></table></figure><h3 id="我已出坑-v2">我已出坑</h3><p>我撞牆多次後，已經為大家修正。</p><p>首先在 conda 環境下輸入 <code>which python</code>，得到以下結果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  ~ <span class="built_in">which</span> python</span><br><span class="line">/Users/lky/miniforge3/bin/python</span><br></pre></td></tr></table></figure><p>然後把輸出的路徑放到以下 cmake 指令中，PYTHON3_EXECUTABLE 後面那串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cmake \</span><br><span class="line">  -DCMAKE_SYSTEM_PROCESSOR=arm64 \</span><br><span class="line">  -DCMAKE_OSX_ARCHITECTURES=arm64 \</span><br><span class="line">  -DWITH_OPENJPEG=OFF \</span><br><span class="line">  -DWITH_IPP=OFF \</span><br><span class="line">  -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">  -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> \</span><br><span class="line">  -D OPENCV_EXTRA_MODULES_PATH=/Library/OpenCV/opencv_contrib-4.5.3/modules \</span><br><span class="line">  -D PYTHON3_EXECUTABLE=&lt;替換成 <span class="built_in">which</span> python 給你的輸出&gt; \</span><br><span class="line">  -D BUILD_opencv_python2=OFF \</span><br><span class="line">  -D BUILD_opencv_python3=ON \</span><br><span class="line">  -D INSTALL_PYTHON_EXAMPLES=ON \</span><br><span class="line">  -D INSTALL_C_EXAMPLES=OFF \</span><br><span class="line">  -D OPENCV_ENABLE_NONFREE=ON \</span><br><span class="line">  -D BUILD_EXAMPLES=ON ../</span><br></pre></td></tr></table></figure><p>接著輸入 <code>make -j8</code>，這就是編譯的步驟。</p><p>j8 就是用八個核心，目前能買到的 Apple Silicon 都是八個核心，所以也沒有改多的空間了。</p><p>給大家看看我編譯的過程：</p><p><img src="/content/images/install_opencv_and_tensorflow_for_python_on_applesilicon/make_j8.png" alt=""></p><p>編譯完成後，執行 <code>sudo make install</code>，這一步就算完成了。</p><h2 id="Step-4-連結-OpenCV">Step 4: 連結 OpenCV</h2><p>將 macOS 上的 OpenCV 4 符號鏈接到虛擬環境 site-packages</p><p>輸入 <code>mdfind cv2.cpython</code> 應該能看到這兩行以「.so」結尾的路徑，其他的路徑不管他</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  ~ mdfind cv2.cpython</span><br><span class="line">/Library/OpenCV/opencv-4.5.3/build/lib/python3/cv2.cpython-39-darwin.so</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/python3.9/site-packages/cv2/python-3.9/cv2.cpython-39-darwin.so</span><br><span class="line">...(其他的路徑不管他)...</span><br></pre></td></tr></table></figure><p>我們要在虛擬環境的 site-packages 中產生一個假的「cv2.so」，實際上是連結到剛才編譯出來的那個「cv2.cpython-39-darwin.so」</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/&lt;你的使用者名稱&gt;/miniforge3/lib/python3.9/site-packages</span><br><span class="line">ln -s /Library/OpenCV/opencv-4.5.3/build/lib/python3/cv2.cpython-39-darwin.so cv2.so</span><br></pre></td></tr></table></figure><p>這一步做完，OpenCV 應該就安裝到 Python 能用了。來測試一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate</span><br><span class="line">python -c <span class="string">&quot;import cv2 as cv;print(cv.__version__)&quot;</span></span><br></pre></td></tr></table></figure><p>結果應該要出現「4.5.3」。</p><h2 id="Step-5-安裝-TensorFlow">Step 5: 安裝 TensorFlow</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate</span><br><span class="line">python -m pip install tensorflow-macos</span><br></pre></td></tr></table></figure><p>這一步做完，TensorFlow 應該就安裝到 Python 能用了。來測試一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate</span><br><span class="line">python -c <span class="string">&quot;import tensorflow as tf;print(tf.__version__);print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot;</span></span><br></pre></td></tr></table></figure><p>結果應該要出現「2.5.0」還有以下隨機內容的 Tensor：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.Tensor(-48.841095, shape=(), dtype=float32)</span><br></pre></td></tr></table></figure><p>到這裡，以下這些套件就安裝完成：</p><ul><li>針對 Apple Silicon 最佳化的 Python 3.9</li><li>OpenCV 4.5.3</li><li>TensorFlow 2.5.0</li></ul><p>另外這些常用的 package 都這樣安裝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda install matplotlib</span><br><span class="line">conda install scikit-image</span><br><span class="line">conda install scikit-learn</span><br><span class="line">conda install pandas</span><br></pre></td></tr></table></figure><p>以後使用之前，都必須要先 <code>conda activate</code> 進入虛擬環境，這是目前還有一點不完美的地方。</p><h2 id="參考資料">參考資料</h2><ul><li>國外大神 <a href="https://sayak.dev/install-opencv-m1/">https://sayak.dev/install-opencv-m1/</a></li><li>Apple 官方的 TensorFlow 插件 <a href="https://developer.apple.com/metal/tensorflow-plugin/">https://developer.apple.com/metal/tensorflow-plugin/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我來證明 Apple Silicon 現在也可以煉丹了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/content/images/install_opencv_and_tensorflow_for_python_on_applesilicon/about_the_mac.png&quot;</summary>
      
    
    
    
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="機器學習" scheme="https://mosdeo.github.io/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
    <category term="AI" scheme="https://mosdeo.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Docker部署測試用文章</title>
    <link href="https://mosdeo.github.io/2021/07/24/Docker%E9%83%A8%E7%BD%B2%E6%B8%AC%E8%A9%A6%E7%94%A8%E6%96%87%E7%AB%A0/"/>
    <id>https://mosdeo.github.io/2021/07/24/Docker%E9%83%A8%E7%BD%B2%E6%B8%AC%E8%A9%A6%E7%94%A8%E6%96%87%E7%AB%A0/</id>
    <published>2021-07-24T16:00:00.000Z</published>
    <updated>2021-07-25T17:06:57.832Z</updated>
    
    <content type="html"><![CDATA[<p>驗證是不是可以 Docker 部署？</p><p>成功的話，我就不用在新電腦上搞麻煩的 node 與 hexo 環境了。</p><hr><p><img src="/content/images/hexo_into_docker.png" alt=""></p><p>這一條拖了一年多的 to do list，終於在今天完成了（淚～）</p><p>但其實寫之前就想很久了，真要算下來都不只兩年了。</p><p>原始碼：https://github.com/mosdeo/HexoContainer</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;驗證是不是可以 Docker 部署？&lt;/p&gt;
&lt;p&gt;成功的話，我就不用在新電腦上搞麻煩的 node 與 hexo 環境了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/content/images/hexo_into_docker.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="docker" scheme="https://mosdeo.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>近期機器學習工作踩到的5個坑</title>
    <link href="https://mosdeo.github.io/2021/05/18/%E8%BF%91%E6%9C%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%88%B0%E7%9A%845%E5%80%8B%E5%9D%91/"/>
    <id>https://mosdeo.github.io/2021/05/18/%E8%BF%91%E6%9C%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%88%B0%E7%9A%845%E5%80%8B%E5%9D%91/</id>
    <published>2021-05-18T16:00:00.000Z</published>
    <updated>2021-07-25T13:54:13.288Z</updated>
    
    <content type="html"><![CDATA[<p>最近主管突然想要大家識別某種生活物品，然後大家就卯起來幹了。</p><h2 id="第一坑：數據少">第一坑：數據少</h2><p>一開始的問題是樣本極少，第一天還不到10張，之後也可預見的不好蒐集，所以其他人一頭熱用 YOLO 之類的演算法同時，我評估深度學習不是好方法。越老舊的方法雖然上限越低，但可解釋性比較好，一般來說需要的數據量比較少。</p><p>都用一些比較傳統的方法，一開始先用 Cascade（就是 Viola–Jones 那個）</p><h2 id="第二坑：老演算法被新版棄用">第二坑：老演算法被新版棄用</h2><p>這裡就來了第一個大坑，OpenCV 4.X 已經拿掉了 Cascade 相關的東西，網路上一找可以看到很多人抱怨，當然抱怨大本營是 Github issue，官方建議大家改用 DNN，但還是很多人想要用復古的東西。</p><p>好吧，我只好降低版本到 3.X，這連帶讓我找適合的 docker image 基底都變得困難（因為編譯 OpenCV 太久，不能每次都編譯），還好最後還是找到了。</p><p>然後隨著樣本增加到幾百個，效果也不是很好。中間還做了哪些努力？因為我自己的 MacBook Air 很慢，所以花了很多時間寫 Dockerfile 還有一些部署相關的 bash，讓計算可以在公司的服務器上跑。但 docker build 與 debug 還是吃自己電腦上的算力，電腦不夠快的影響還是有。</p><p>後來覺得為了 debug 而 docker build 的次數太多了、太浪費時間，所以決定：</p><ul><li>Dockerfile 只做 apt install 或 pip install 之類的事，所有的程式碼、數據全都用 mount 的。</li><li>所有的流程都寫在 docker run 最後面的指令（/bin/bash -c “…”）</li><li>docker image、程式碼、數據集，各用一個 bash deploy 到 GPU server。</li></ul><h2 id="第三坑：用錯特徵">第三坑：用錯特徵</h2><p>後來我就發現，預設的特徵擷取法是 Haar，那個是針對人臉的明暗變化擷取特徵，不太適合現在的檢測目標。另外兩種可選特徵是 LBP 與 HoG，這兩種我都在寫論文或寫作業自乾過了，HoG 應該是最佳選擇。理論上，這只要改個參數就可以看到辨識率爆炸性的推進了吧？我以為看到了一條很棒的近路。</p><h2 id="第四坑：適合的特徵又被-Python-版棄用">第四坑：適合的特徵又被 Python 版棄用</h2><p>結果發現 OpenCV 3.X 可以訓練基於 HoG 的 Cascade 模型，但是卻不能 load 基於 HoG 的 XML model？必須要 2.X 才能，那我就再度降低版本到 2.X 吧！這次更慘，發現沒得降低了，因為 Python 的 OpenCV 最低就是從 3.X 開始，如果降低到 OpenCV 2.X 那從 load XML model 以後的所有事情我都要用 CPP 寫，太累了！</p><p>https://github.com/shimat/opencvsharp/issues/1022</p><p>搜一下發現很多人用 HoG + SVM 的組合做目標檢測，尤其行人與車輛，感覺還蠻適合現在的目標。發現用的函式庫有兩大派別，老的 OpenCV 與新的 scikit-image。</p><h2 id="第五坑：造好的輪子還是要自己補胎">第五坑：造好的輪子還是要自己補胎</h2><p>然後就找一下 Github 現成的輪子，發現有一個看起來寫得不錯、夠規整、文件夠清楚，有把一些設定獨立在 config.cfg。clone 下來之後發現是除了 Python2 之外，還有一些錯字、一些API過時了，改了將近一天才跑起來。</p><p>跑起來之後有坑啊，一直跑出「array has an inhomogeneous shape after 1 dimensions.」，原來是我的訓練圖片大小都不一樣，沒有經過正規化。給模型的所有數據維度都要一樣大，這其實應該是個機器學習常識才對，甚至也是統計常識，只是現成的工具太方便了，習慣都被養壞了。</p><p>接下又要繼續解這個不是坑的坑…（待續）</p><p>（還有一些數據視覺化的坑沒寫，不過我懶了，下次再寫）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近主管突然想要大家識別某種生活物品，然後大家就卯起來幹了。&lt;/p&gt;
&lt;h2 id=&quot;第一坑：數據少&quot;&gt;第一坑：數據少&lt;/h2&gt;
&lt;p&gt;一開始的問題是樣本極少，第一天還不到10張，之後也可預見的不好蒐集，所以其他人一頭熱用 YOLO 之類的演算法同時，我評估深度學習不是好方</summary>
      
    
    
    
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="機器學習" scheme="https://mosdeo.github.io/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
    <category term="AI" scheme="https://mosdeo.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>如何用Docker高效部署Python寫的機器學習推論服務</title>
    <link href="https://mosdeo.github.io/2021/05/01/%E5%A6%82%E4%BD%95%E7%94%A8Docker%E9%AB%98%E6%95%88%E9%83%A8%E7%BD%B2Python%E5%AF%AB%E7%9A%84%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E6%8E%A8%E8%AB%96%E6%9C%8D%E5%8B%99/"/>
    <id>https://mosdeo.github.io/2021/05/01/%E5%A6%82%E4%BD%95%E7%94%A8Docker%E9%AB%98%E6%95%88%E9%83%A8%E7%BD%B2Python%E5%AF%AB%E7%9A%84%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E6%8E%A8%E8%AB%96%E6%9C%8D%E5%8B%99/</id>
    <published>2021-05-01T16:00:00.000Z</published>
    <updated>2021-05-02T01:50:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>這一篇是我個人近期的經驗總結。個人感覺與 Docker 相見恨晚，要是早點懂，以前做的機器學工具，效果都能放大很多倍了。</p><p>以前總覺得把程式碼放到別的 server、別的電腦上跑，要搞定各種環境細節上的差異，是一件骯髒的苦差事。自從有了 Docker，一切都變得輕鬆快速無負擔。</p><p><img src="/content/images/DockerDeploy.png" alt=""></p><p>每次一鍵部署（如上圖）都覺得很爽快！從改完程式碼到上線生效，就只有一行指令的距離（前提是網路穩定、指令編寫正確）。</p><h2 id="準備">準備</h2><ul><li>必須：<ul><li>開發機＆目標機，都要安裝 Docker</li><li>至少需要寫一個簡單 server（建議 Python+Flask），方便推論數據進出虛擬機</li></ul></li><li>建議：盡可能不要把只有訓練才用到的東西（程式碼、數據、函式庫）部署出去，所以能做以下這些事：<ul><li>「訓練＆推論」數據分離<ul><li>不必分開放。兩種數據不在同一個文件內，路徑能區分清楚就好。</li></ul></li><li>「訓練＆推論」城市碼分離<ul><li>前提：模型能存檔，可用 pickle r/w。</li></ul></li><li>pip install 加速與減負<ul><li>–no-cache-dir 映像是免洗筷環境，不快取，爭取輕量</li><li>中國大陸內 proxy<ul><li>pip3 install XXX -i https://mirrors.ustc.edu.cn/pypi/web/simple/</li></ul></li><li>requirements.txt 定向瘦身<ul><li>pip3 install pipreqs</li><li>pipreqs .（在要部署的repo內）</li><li>效果？<ul><li>1.54GB VS 424MB</li><li>大的已經手動刪除很多 package，還是這麼大。手動刪除效果比不上自動工具。</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="觀念">觀念</h2><ol><li>Docker 虛擬機是一個小黑屋</li><li>人可以用，但不能親自操作</li><li>一切操作都要寫在一張紙上，請 Docker 管家代辦</li><li>這張紙叫做 Dockerfile （第一個字母必須大寫）</li></ol><ul><li>Dockerfile 上的交辦事項分兩大類：<ul><li>如何裝修？（一次性設置）</li><li>以後每次進門的慣例？（重複使用）</li></ul></li><li>Dockerfile 的好處＆不足：<ul><li>強迫開發者把環境設定寫成程式碼，可標準化、可輕易重復。</li><li>對機器學習來說，Dockerfile 只能標準化推論與部署。訓練與演算法的內涵 Docker 管不到，還是要主動寫才會留下。（這句看起來很像「一分鐘有60秒」之類的廢話，但很真的很多主管不懂機器學習）</li></ul></li><li>Dockerfile 將會與 Python 程式碼一起維護，是整個 repo 程式碼的一部分。</li><li>Dockerfile 的寫法，就是打包服務的重點。</li></ul><h2 id="操作">操作</h2><ul><li>撰寫 Dockerfile</li><li>docker build（裝修）</li><li>docker run（執行慣例）</li><li>上述操作失敗的應對方式：說清楚太麻煩，我靠大量練習與肌肉記憶</li></ul><h2 id="延伸">延伸</h2><ul><li>Python官方鏡像各版本差異<ul><li>https://hub.docker.com/_/python Image_Variants</li></ul></li><li>製作運行 Python 的 docker image 前，如何選擇 docker 基底鏡像？<ul><li>https://aws.amazon.com/cn/blogs/china/choose-the-best-docker-image-for-your-python-application/</li></ul></li><li>bash 一鍵部署<ul><li>如何撰寫 bash</li><li>Linux 子帳號權限設置</li><li>put ssh pub key to the server</li></ul></li><li>log 或其他 container 產生數據<ul><li>container 如免洗餐具，隨時消失、隨時可棄，不應該留存數據。</li><li>數據保存應該用 mount 或 volume。</li></ul></li></ul><h2 id="待解決問題：">待解決問題：</h2><ul><li>Python 演算法或模型，是否應該用 mount 做到彈性更新？</li><li>多個虛擬機連動：docker compose</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這一篇是我個人近期的經驗總結。個人感覺與 Docker 相見恨晚，要是早點懂，以前做的機器學工具，效果都能放大很多倍了。&lt;/p&gt;
&lt;p&gt;以前總覺得把程式碼放到別的 server、別的電腦上跑，要搞定各種環境細節上的差異，是一件骯髒的苦差事。自從有了 Docker，一切都變得</summary>
      
    
    
    
    
    <category term="機器學習" scheme="https://mosdeo.github.io/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
    <category term="後端" scheme="https://mosdeo.github.io/tags/%E5%BE%8C%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>為什麼物聯網落地困難、賣點稀少、有價值數據獲取困難，大多只能作為噱頭？談我的經驗</title>
    <link href="https://mosdeo.github.io/2020/12/09/%E7%82%BA%E4%BB%80%E9%BA%BC%E7%89%A9%E8%81%AF%E7%B6%B2%E8%90%BD%E5%9C%B0%E5%9B%B0%E9%9B%A3%E3%80%81%E8%B3%A3%E9%BB%9E%E7%A8%80%E5%B0%91%E3%80%81%E6%9C%89%E5%83%B9%E5%80%BC%E6%95%B8%E6%93%9A%E7%8D%B2%E5%8F%96%E5%9B%B0%E9%9B%A3%EF%BC%8C%E5%A4%A7%E5%A4%9A%E5%8F%AA%E8%83%BD%E4%BD%9C%E7%82%BA%E5%99%B1%E9%A0%AD%EF%BC%9F%E8%AB%87%E6%88%91%E7%9A%84%E7%B6%93%E9%A9%97/"/>
    <id>https://mosdeo.github.io/2020/12/09/%E7%82%BA%E4%BB%80%E9%BA%BC%E7%89%A9%E8%81%AF%E7%B6%B2%E8%90%BD%E5%9C%B0%E5%9B%B0%E9%9B%A3%E3%80%81%E8%B3%A3%E9%BB%9E%E7%A8%80%E5%B0%91%E3%80%81%E6%9C%89%E5%83%B9%E5%80%BC%E6%95%B8%E6%93%9A%E7%8D%B2%E5%8F%96%E5%9B%B0%E9%9B%A3%EF%BC%8C%E5%A4%A7%E5%A4%9A%E5%8F%AA%E8%83%BD%E4%BD%9C%E7%82%BA%E5%99%B1%E9%A0%AD%EF%BC%9F%E8%AB%87%E6%88%91%E7%9A%84%E7%B6%93%E9%A9%97/</id>
    <published>2020-12-09T16:00:00.000Z</published>
    <updated>2021-02-02T06:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="裝置電力短缺">裝置電力短缺</h2><p>物聯網裝置通常都是吃電池，很少有插電的機會。新硬件設計的時候，最大瓶頸是裝置的電力有限，但各部門都想在裝置上加入對自己有利的耗電項目。</p><p>行銷部門想放廣告、GIS 部門想裝 GPS、維運部門想寫入更多的 log、跟醫院合作的部門想裝運動感測器等等，這些需求都在爭搶極其有限的電力。給這些裝置充電，比給自己的手機半天一充還要困難。</p><p>為了裝更多的感測器，我連「用 DMA 節省 CPU 耗電」、「常態休眠，等感測器發出中斷再喚醒」這些很韌體技巧都提出來了，我還自己去查感測器的 datasheet 想辦法找出耗電量比較少的型號。</p><h2 id="數據孤島">數據孤島</h2><p>這個問題已經在網上被介紹過很多次，就不詳述。數據孤島有企業與企業之間的、也有部門與部門之間的，沒有統一的標準、沒有流通的數據，也會降低的數據的價值。一但被認定數據的價值不夠，在上一點「裝置電力短缺」就會被否決安裝感測器的需求。</p><p>通常數據價值已經被管理層看到的時候，都是別家企業已經拿數據做出應用、講出故事的時候，這時候想在營運中的系統加上感測器已經來不及，就算裝了，應用場域的機會與話語權，也早已經被先行的企業拿下。</p><style>    .center {    display: block;    margin-left: auto;    margin-right: auto;    width: 50%;    }</style><p>    <img src="/content/images/YouBike_1VS2.webp" class="center"></p><p>上圖是我參與過初期規劃階段的產品，我離職時：</p><ul><li><p>參考了很多中國大陸共享單車的方案，呼聲最高是類似現在中國大陸實行的虛擬停車柱/停車區，最後不知道為什麼沒採用，但不論開發商或當局政府都採取很保守的態度，很多先進的提案都沒實施，估計是被「單車墳場」的文章嚇到了。</p></li><li><p>當時落地營運的還只有 1.0，1.0 上沒有任何感測器或長距離通訊裝置，只有一組向停車柱回報車 ID，類似 NFC 的線圈。</p></li><li><p>2.0 版連塗裝都是我離職多年後才在路上看到，也不知道當年提案的感測器到底裝了哪些…</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;裝置電力短缺&quot;&gt;裝置電力短缺&lt;/h2&gt;
&lt;p&gt;物聯網裝置通常都是吃電池，很少有插電的機會。新硬件設計的時候，最大瓶頸是裝置的電力有限，但各部門都想在裝置上加入對自己有利的耗電項目。&lt;/p&gt;
&lt;p&gt;行銷部門想放廣告、GIS 部門想裝 GPS、維運部門想寫入更多的 l</summary>
      
    
    
    
    
    <category term="運動" scheme="https://mosdeo.github.io/tags/%E9%81%8B%E5%8B%95/"/>
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
    <category term="批判" scheme="https://mosdeo.github.io/tags/%E6%89%B9%E5%88%A4/"/>
    
    <category term="靠盃" scheme="https://mosdeo.github.io/tags/%E9%9D%A0%E7%9B%83/"/>
    
    <category term="技術" scheme="https://mosdeo.github.io/tags/%E6%8A%80%E8%A1%93/"/>
    
    <category term="YouBike" scheme="https://mosdeo.github.io/tags/YouBike/"/>
    
    <category term="公共運輸" scheme="https://mosdeo.github.io/tags/%E5%85%AC%E5%85%B1%E9%81%8B%E8%BC%B8/"/>
    
    <category term="單車" scheme="https://mosdeo.github.io/tags/%E5%96%AE%E8%BB%8A/"/>
    
    <category term="韌體" scheme="https://mosdeo.github.io/tags/%E9%9F%8C%E9%AB%94/"/>
    
  </entry>
  
  <entry>
    <title>我在微信公眾號上的文章清單(滾動更新)</title>
    <link href="https://mosdeo.github.io/2020/09/12/%E6%88%91%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E7%9C%BE%E8%99%9F%E4%B8%8A%E7%9A%84%E6%96%87%E7%AB%A0%E6%B8%85%E5%96%AE_%E6%BB%BE%E5%8B%95%E6%9B%B4%E6%96%B0/"/>
    <id>https://mosdeo.github.io/2020/09/12/%E6%88%91%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E7%9C%BE%E8%99%9F%E4%B8%8A%E7%9A%84%E6%96%87%E7%AB%A0%E6%B8%85%E5%96%AE_%E6%BB%BE%E5%8B%95%E6%9B%B4%E6%96%B0/</id>
    <published>2020-09-12T16:00:00.000Z</published>
    <updated>2020-12-10T08:31:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>由於在微信的資料池裡面，搜尋我自己的名字，會被某個同名同姓的乒乓球選手新聞淹沒，所以我特地把自己發表在微信公眾號上的文章做一個清單，方便我自己查閱。</p><h3 id="技術">技術</h3><h4 id="Go语言中文网">Go语言中文网</h4><p>2020-09-13 <a href="https://mp.weixin.qq.com/s/pP3hJKa-EGvLXi0luL1cRg">面试官：这个经典的并发问题用 Go 语言如何实现？</a></p><p>2020-04-03 <a href="https://mp.weixin.qq.com/s/K032xlARjiyS8ecJrqZXaA">LeetCode Go 并发题详解：交替打印字符串</a></p><p>2020-02-19 <a href="https://mp.weixin.qq.com/s/zMZXd8DLtjhm06Q0lm1pcg">只在我计算机上能跑的代码：select-case-default 忘记让出 CPU 的坑</a></p><p>2020-02-16 <a href="https://mp.weixin.qq.com/s/WJJL-3pkeA8qBF75QTt9Ag">面试题实战：给一个数 n，使用 Go 打印交替顺序零与奇偶数</a></p><p>2020-02-11 <a href="https://mp.weixin.qq.com/s/wL-Cy6DScmPIpQAma6_3Qw">多 Goroutine 的并发程序如何保证按序输出？channel 的使用是关键</a></p><p>2020-02-04 <a href="https://mp.weixin.qq.com/s/I5va3PI1oGIj8R_n3Nw2yw">LeetCode上并发题目无Go版本：台湾同胞试水 — 交替打印FooBar</a></p><h3 id="非技術">非技術</h3><p>2020-02-14 <a href="https://mp.weixin.qq.com/s/9KEpxb6h6aGJvMnQXUS_Hg">在台湾亲身经历约口罩抢购热潮…</a></p><p>2020-02-11 <a href="https://mp.weixin.qq.com/s/iBBroMhDxz1VYJiI62QYMw">我在台湾亲历口罩抢购潮 | 人在书店×2002</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由於在微信的資料池裡面，搜尋我自己的名字，會被某個同名同姓的乒乓球選手新聞淹沒，所以我特地把自己發表在微信公眾號上的文章做一個清單，方便我自己查閱。&lt;/p&gt;
&lt;h3 id=&quot;技術&quot;&gt;技術&lt;/h3&gt;
&lt;h4 id=&quot;Go语言中文网&quot;&gt;Go语言中文网&lt;/h4&gt;
&lt;p&gt;2020-</summary>
      
    
    
    
    
    <category term="大陸" scheme="https://mosdeo.github.io/tags/%E5%A4%A7%E9%99%B8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：經典哲學家吃飯問題：碰運氣解法</title>
    <link href="https://mosdeo.github.io/2020/09/01/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_%E7%B6%93%E5%85%B8%E5%93%B2%E5%AD%B8%E5%AE%B6%E5%90%83%E9%A3%AF%E5%95%8F%E9%A1%8C_%E7%A2%B0%E9%81%8B%E6%B0%A3%E8%A7%A3%E6%B3%95/"/>
    <id>https://mosdeo.github.io/2020/09/01/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_%E7%B6%93%E5%85%B8%E5%93%B2%E5%AD%B8%E5%AE%B6%E5%90%83%E9%A3%AF%E5%95%8F%E9%A1%8C_%E7%A2%B0%E9%81%8B%E6%B0%A3%E8%A7%A3%E6%B3%95/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2020-09-02T13:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/the-dining-philosophers/">https://leetcode.com/problems/the-dining-philosophers/</a></p><h2 id="本題題目">本題題目</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/400px-An_illustration_of_the_dining_philosophers_problem.png" alt=""></p><p>「哲學家吃飯問題」是一個作業系統中的經典問題，所以抽象題幹我就不再贅述，直接說實作要求。</p><blockquote><p>The philosophers’ ids are numbered from 0 to 4 in a clockwise order. Implement the function void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) where:</p></blockquote><p>有幾位哲學家，他們的 ID 順時針由 0~4，實作一個函數 <code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code>，其中…</p><blockquote><p>philosopher is the id of the philosopher who wants to eat.</p></blockquote><p>參數 <code>philosopher</code> 代表想要吃飯的哲學家的 ID。</p><blockquote><p>pickLeftFork and pickRightFork are functions you can call to pick the corresponding forks of that philosopher.</p></blockquote><p>參數 <code>pickLeftFork</code> and <code>pickRightFork</code> 是函數，你必須呼叫他們來使哲學家拿起對應的叉子。</p><blockquote><p>eat is a function you can call to let the philosopher eat once he has picked both forks.</p></blockquote><p>當哲學家拿起兩隻叉子後，你必須呼叫 <code>eat</code> 這個函數讓哲學家吃一次。</p><blockquote><p>putLeftFork and pickRightFork are functions you can call to put down the corresponding forks of that philosopher.</p></blockquote><p>參數 <code>putLeftFork</code> and <code>pickRightFork</code> 是函式，你必須呼叫他們來使哲學家放下手中的叉子。</p><blockquote><p>The philosophers are assumed to be thinking as long as they are not asking to eat (the function is not being called with their number).</p></blockquote><p>假設哲學家們都會思考很久，中間都不會要求吃東西（呼叫函式 thinking() 不必使用哲學家們的 ID）</p><blockquote><p>Five threads, each representing a philosopher, will simultaneously use one object of your class to simulate the process. It is possible that the function will be called for the same philosopher more than once, even before the last call ends.</p></blockquote><p>五個執行緒，每一個執行緒代表都一個哲學家，用一個類(在 Go 語言是 struct)模擬這個 process。這個函式可能被同一個哲學家呼叫多次，甚至在最後一次呼叫結束前的途中都有可能。</p><h2 id="「叉子」與「筷子」">「叉子」與「筷子」</h2><p>最早課本裡都是說「叉子」。但我大學上 OS 的時候老師就提過一個疑問：「用叉子吃義大利麵，一隻就夠了，沒必要用到兩隻吧？所以，改成用筷子是不是更合理一點？但沒辦法，誰叫這門學問是西方先發明的？我們就當作筷子吧」。<br>於是，本文也決定照改，以下都用「筷子」代替「叉子」。</p><h2 id="本題考核難點？「拿得起放不下」造成死結、「無限輪迴」造成活結飢餓至死">本題考核難點？「拿得起放不下」造成死結、「無限輪迴」造成活結飢餓至死</h2><p>在過去的 LeetCode Concurrency 詳解中，我提到過很多次：</p><blockquote><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 順序控制的能力。</p></blockquote><p>但前面幾題的解法，大多是把判斷責任中心化，方便控管順序。這次，與前面幾題不同的是，這一題要求把判斷責任分散到每一位哲學家 thread 身上，哲學家彼此之間並不溝通，因此很容易發生資源互卡，也就是 deadlock。本文所示範的 channel 使用方法已經完全避免了死結(deadlock)。但這樣就沒問題了嗎？不，還有可能發生<a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81#%E6%B4%BB%E7%B5%90">活結(livelock)</a>。</p><p>這邊我為了示範 goroutine，先用最笨的碰運氣解法，也就是不刻意做任何資源配置，要在運氣很壞的情況下才會遇上 livelock。什麼是「運氣很壞的情況」？就是所有哲學家剛好在同一時間拿起同一邊的叉子。但實作上，由於我給每位哲學家一個隨機的思考時間 50mS（如下列程式碼），碰撞的機會是(1/50)^5，所以絕大部分情況下不會發生 livelock。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Think</span><span class="params">()</span></span> &#123;</span><br><span class="line">Random := <span class="function"><span class="keyword">func</span><span class="params">(max <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line"><span class="keyword">return</span> rand.Int() % (max + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-time.After(time.Millisecond * time.Duration(Random(<span class="number">50</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wiki 上有介紹不需要碰運氣，保證不會讓 thread 飢餓致死的演算法，但我自己也沒搞懂，請容我日後再介紹。</p><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><p>本題採用 5 個 buffered channel，分別代表 5 支筷子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DiningPhilosophers <span class="keyword">struct</span> &#123;</span><br><span class="line">wg                     *sync.WaitGroup</span><br><span class="line">streamForks            [<span class="number">5</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">missingDoubleForkTimes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Channel 初始化</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> diningPhilosophers.streamForks &#123;</span><br><span class="line">diningPhilosophers.streamForks[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叫所有哲學家開始動作</span></span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> diningPhilosophers.streamForks &#123;</span><br><span class="line">diningPhilosophers.wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> diningPhilosophers.WantToEat(i, PickLeftFork, PickRightFork, Eat, PutLeftFork, PutRightFork)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊開始計時後，是一個 foreach。<br>老方法，用 <code>sync.WaitGroup</code> 同步 5 個哲學家 goroutine 結束時間。<br>給每一位哲學家起一個「WantToEat」的 goroutine，告訴他 i 你是幾號？又給入「PickLeftFork, PickRightFork, Eat, PutLeftFork, PutRightFork」五個函式的的 function reference。</p><h3 id="2-五個-goroutine-之間，如何交接棒？">2. 五個 goroutine 之間，如何交接棒？</h3><p>沒有交接棒問題，每位哲學家就憑運氣去搶左右邊的兩隻筷子。<br>要注意的只有三件事情：</p><ol><li>無法同時搶到兩隻筷子的哲學家，必須先放棄到手的一支筷子。</li><li>已經同時搶到兩隻筷子的哲學家，吃完就必須退出餐桌。</li><li>還沒吃到的哲學家，可以無限次搶。</li></ol><h4 id="自循環-外部啟動注意事項">自循環 &amp; 外部啟動注意事項</h4><p>這次解題沒有實作這些協調機制，5 個 goroutine 只靠前述的三條規範野蠻生長。</p><h4 id="實作前述的三條規範的-WantToEat">實作前述的三條規範的 WantToEat()</h4><ul><li>本質上就是代表「還沒吃到的哲學家，可以無限次搶」的無限迴圈。</li><li>「已經同時搶到兩隻筷子的哲學家，吃完就必須退出餐桌」是此迴圈的結束條件。</li><li>「無法同時搶到兩隻筷子的哲學家，必須先放棄到手的一支筷子。」是此迴圈其中一個分支。</li></ul><p>有一行「<code>return //吃飽離開</code>」，整個流程最終目的就是要走到這一行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DiningPhilosophers)</span> <span class="title">WantToEat</span><span class="params">(philosopher <span class="keyword">int</span>, pickLeftFork <span class="keyword">func</span>(<span class="keyword">int</span>)</span>, <span class="title">pickRightFork</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>, <span class="title">eat</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>, <span class="title">putLeftFork</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>, <span class="title">putRightFork</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> this.wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> leftNum = (philosopher + <span class="number">4</span>) % <span class="number">5</span>  <span class="comment">//取得該哲學家左邊的號碼</span></span><br><span class="line"><span class="keyword">var</span> rightNum = (philosopher + <span class="number">6</span>) % <span class="number">5</span> <span class="comment">//取得該哲學家右邊的號碼</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> this.streamForks[leftNum] &lt;- philosopher: <span class="comment">//嘗試拿起左邊筷子</span></span><br><span class="line">PickLeftFork(philosopher) <span class="comment">//成功拿起左邊筷子</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> this.streamForks[rightNum] &lt;- philosopher: <span class="comment">//嘗試拿起右邊筷子</span></span><br><span class="line">PickRightFork(philosopher)  <span class="comment">//成功拿起又邊筷子</span></span><br><span class="line">Eat(philosopher)            <span class="comment">//左右邊都拿到了，開始吃</span></span><br><span class="line">&lt;-this.streamForks[leftNum] <span class="comment">//吃完了，放下左邊筷子</span></span><br><span class="line">PutLeftFork(philosopher)</span><br><span class="line">&lt;-this.streamForks[rightNum] <span class="comment">//吃完了，放下右邊筷子</span></span><br><span class="line">PutRightFork(philosopher)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//吃飽離開</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//無法拿起右邊筷子</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Philosopher %d can&#x27;t pick fork %d.\n&quot;</span>, philosopher, rightNum)</span><br><span class="line">&lt;-this.streamForks[leftNum] <span class="comment">//把已經拿起來的左邊筷子釋放出去</span></span><br><span class="line">PutLeftFork(philosopher)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//無法拿起左邊筷子</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Philosopher %d can&#x27;t pick fork %d.\n&quot;</span>, philosopher, leftNum)</span><br><span class="line">&#125;</span><br><span class="line">this.missingDoubleForkTimes++</span><br><span class="line">Think()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊對於每一隻筷子的具體表現就是一個 buffered channel，迴圈流程如下：</p><ol><li><p>先嘗試把自己的號碼塞入左邊的 buffered channel</p><ul><li>成功了，就是搶到一隻筷子，往下。</li><li>失敗了，跳到「<code>default: //無法拿起左邊筷子</code>」，思考一下，然後從頭開始。</li></ul></li><li><p>再嘗試把自己的號碼塞入右邊的 buffered channel</p><ul><li>成功了，就是搶到兩隻筷子，開始吃，吃飽離開，退出餐桌。</li><li>失敗了，跳到「<code>default: //無法拿起右邊筷子</code>」，把已經搶到的左邊筷子還回去，思考一下，然後從頭開始。</li></ul></li></ol><p>在 console 輸出，可以看到代表每一位哲學家的 goroutine 詳細動作過程，錯過筷子次數並不多，大部分執行結果的錯過次數在 3~5 次（點擊以下的「完整解題程式碼」就能體驗）。</p><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p><a href="https://play.golang.org/p/neTH25E8ayX">https://play.golang.org/p/neTH25E8ayX</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/DiningPhilosophersProblem%E7%A4%BA%E6%84%8F%E5%9C%9620200902.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。&lt;/p&gt;
&lt;h2 id=&quot;本題-LeetCode-連結：&quot;&gt;本題 Leet</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>眾說紛紜的生長激素調控因子整理</title>
    <link href="https://mosdeo.github.io/2020/06/29/%E7%9C%BE%E8%AA%AA%E7%B4%9B%E7%B4%9C%E7%9A%84%E7%94%9F%E9%95%B7%E6%BF%80%E7%B4%A0%E8%AA%BF%E6%8E%A7%E5%9B%A0%E5%AD%90/"/>
    <id>https://mosdeo.github.io/2020/06/29/%E7%9C%BE%E8%AA%AA%E7%B4%9B%E7%B4%9C%E7%9A%84%E7%94%9F%E9%95%B7%E6%BF%80%E7%B4%A0%E8%AA%BF%E6%8E%A7%E5%9B%A0%E5%AD%90/</id>
    <published>2020-06-29T16:00:00.000Z</published>
    <updated>2020-07-08T06:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>生長激素（Growth Hormone；GH）對於想要健身長肌肉的人來說，是特別重要的一項荷爾蒙，因為他能促進肌肉生長、又加速消耗脂肪，對於想要明顯線條好身材的人來說是好朋友。</p><p>所以，我們得知道怎樣可以讓生長激素更多？又怎樣避免生長激素減少？這是很多營養健身 YouTuber 會介紹的主題，但是營養健身 YouTuber 偶爾講到有些地方會與課本衝突，所以這邊地特整理:</p><ol><li>我在教科書上找到的生長激素調控因子，讓我們有來源更明確、更權威的根據，掌握自己的生長激素。</li><li>YouTuber 講得比較有疑問之處，留待日後釐清。</li></ol><h2 id="解剖生理學，許世昌著，民國98年永大出版">解剖生理學，許世昌著，民國98年永大出版</h2><p>比較特別的是，這邊寫到胺基酸的增減會影響到生長激素，這是我在其他地方都沒看到的調控因子。</p><p><img src="/content/images/GrowthHormone/IMG_1136.jpg" alt=""></p><h2 id="運動生理學，林正常校閱，2002年麥格羅希爾出版（黑人跑步封面）">運動生理學，林正常校閱，2002年麥格羅希爾出版（黑人跑步封面）</h2><p>這張圖用很清楚的方塊來表示各個因子之間的調控關係，</p><ul><li>生長激素並不是直接增肌，而是傳遞給肝臟，肝臟才以促生長激素(類胰島素生長因子)增肌。</li><li>生長激素的效果會對自身產生負回授。</li></ul><p><img src="/content/images/GrowthHormone/IMG_1137.jpg" alt=""></p><p>然而，書中講到生長激素作用時，強調「靜效果是保持血漿葡萄糖濃度」。若以這點來看，眾多的生長激素調控因子中，可能只有「低血糖」這一項是鐵律，其他或許只是相關，而非因果？</p><p><img src="/content/images/GrowthHormone/IMG_1138.jpg" alt=""></p><p>書中又給了更清楚的量化關係，顯示血中的生長激素與 VO2Max% 有極為強烈的關係！也難怪有些說法是「高強度間歇訓練可促進生長激素」。</p><p><img src="/content/images/GrowthHormone/IMG_1139.jpg" alt=""></p><h2 id="肌力與體能訓練，林貴福等譯，2017禾楓出版（俗稱「藍聖經」）">肌力與體能訓練，林貴福等譯，2017禾楓出版（俗稱「藍聖經」）</h2><p>這本書花了不少篇幅談生長激素，但沒有像其他幾本書說的那麼簡單，關注在相當多模凌兩可或很複雜的點上，例如：</p><ul><li>低強度高反覆的阻力運動(28% 7RM)，不會提高生長激素濃度</li><li>女性對生長激素濃度的反應</li><li>訓練的適應</li><li>IGFs</li></ul><p><img src="/content/images/GrowthHormone/IMG_1170.jpg" alt=""></p><p>真要說這本書讓我認識了什麼新的調控因子？大概就是重訓前後吃些蛋白質醣類吧（如下圖）</p><p><img src="/content/images/GrowthHormone/IMG_1171.jpg" alt=""></p><h2 id="比較【力竭與不力竭】在重訓時的優劣勢｜健人訓練｜2017ep13">比較【力竭與不力竭】在重訓時的優劣勢｜健人訓練｜2017ep13</h2><p><img src="/content/images/GrowthHormone/BFYEnLgWN18.png" alt=""></p><p><a href="https://youtu.be/BFYEnLgWN18?t=314">05:14</a> 所說「氫離子、乳酸可以促進生長激素」，但我目前沒在任何文獻上看到這兩樣物質有被列為生長激素調控因子。</p><p>若更積極一點，進一步去跟生長激素扯上關係？我能想到的是，乳酸會被作為糖質新生的原料用，所以會間接提高血糖，故乳酸會抑制生長激素才對吧？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;生長激素（Growth Hormone；GH）對於想要健身長肌肉的人來說，是特別重要的一項荷爾蒙，因為他能促進肌肉生長、又加速消耗脂肪，對於想要明顯線條好身材的人來說是好朋友。&lt;/p&gt;
&lt;p&gt;所以，我們得知道怎樣可以讓生長激素更多？又怎樣避免生長激素減少？這是很多營養健身 </summary>
      
    
    
    
    
    <category term="運動科學" scheme="https://mosdeo.github.io/tags/%E9%81%8B%E5%8B%95%E7%A7%91%E5%AD%B8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：Fizz Buzz Multithreaded</title>
    <link href="https://mosdeo.github.io/2020/02/22/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_FizzBuzzMultithreaded/"/>
    <id>https://mosdeo.github.io/2020/02/22/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_FizzBuzzMultithreaded/</id>
    <published>2020-02-22T16:00:00.000Z</published>
    <updated>2021-05-02T01:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次將會示範 goroutine 教學中常講到的「不要透過共享來通訊，而要透過通訊來共享」。</p><p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/fizz-buzz-multithreaded/">https://leetcode.com/problems/fizz-buzz-multithreaded/</a></p><h2 id="本題題目">本題題目</h2><p>給定一個數列從 1 ~ n，依序輸出，但是:</p><ul><li>如果 n 可以被 3 整除，輸出 “fizz”</li><li>如果 n 可以被 5 整除，輸出 “buzz”</li><li>如果 n 同時可以被 3 與 5 整除，輸出 “fizzbuzz”</li></ul><p>實作要求：使用 4 個執行緒實現一個多執行緒版本。一個 FizzBuzz 的 instance 要被傳遞到以下四個執行緒中:</p><ul><li>Thread A 會呼叫 <code>fizz()</code>     以檢查 n 是否可以被    3 整除？若可以就輸出 fizz</li><li>Thread B 會呼叫 <code>buzz()</code>     以檢查 n 是否可以被    5 整除？若可以就輸出 buzz</li><li>Thread C 會呼叫 <code>fizzbuzz()</code> 以檢查 n 是否可以被 3, 5 整除？若可以就輸出 fizzbuzz</li><li>Thread D 會呼叫 <code>number()</code>   照常輸出原本數字 n</li></ul><h2 id="本題考核難點？判斷責任去中心化！">本題考核難點？判斷責任去中心化！</h2><p>我一開始認為「這題沒什麼難的嘛～還不就那些套路再用一次！」，所以<a href="https://play.golang.org/p/QkeogzEtS5R">最早的實作版本</a>，是寫了一個中心控管的 goroutine，判斷整除條件後，再把輸出任務透過 channel 發派給其他 goroutine A, B, C, D。</p><p>直到我為了分享這題，將英文題目翻譯為中文的時候，才發現自己誤解題目了(尷尬)！題目真正的要求更困難，要各個 goroutine 自行負擔檢查整除條件的責任。所以只好重寫 XD</p><p>在過去的 LeetCode Concurrency 詳解中，我提到過很多次：</p><blockquote><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 順序控制的能力。</p></blockquote><p>但前面幾題的解法，大多是把判斷責任中心化，方便控管順序。這次，與前面幾題不同的是，這一題要求把判斷責任分散到 thread A, B, C 中，所以每個 goroutine 也無法準確得知下一個要接棒的 goroutine 是哪一個？這樣的順序控制會由於分散化，變得更加困難。</p><blockquote><p>By the way，我還解過「DiningPhilosophers」這一題用的就是去中心化方法，但目前還沒寫那一題詳解。</p></blockquote><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FizzBuzz <span class="keyword">struct</span> &#123;</span><br><span class="line">n           <span class="keyword">int</span></span><br><span class="line">wg          *sync.WaitGroup</span><br><span class="line">streamBaton <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fizzbuzz := &amp;FizzBuzz&#123;</span><br><span class="line">n:           testCase,</span><br><span class="line">wg:          &amp;sync.WaitGroup&#123;&#125;,</span><br><span class="line">streamBaton: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依照題目採用一個 FizzBuzz 物件 pass 到各個 goroutine 之中，當中有 buffered channel <code>streamBaton</code> 長度為一，可儲存一個整數。</p><h3 id="2-四個-goroutine-之間，如何交接棒？">2. 四個 goroutine 之間，如何交接棒？</h3><p>這一題在 goroutine 之間交接棒的規則更複雜，所以我決定不像之前一樣指定的交接棒，而是每一個 goroutine 都把訊息丟到同一個 channel 裡面去，大家都去「各取所需」，看看是不是符合自己的整除規則？如果不是，表示自己還沒接到棒，要把數字再寫回 channel 讓應該接這一棒的 goroutine 可以讀取到資訊。</p><p>這樣有壞處，那就是會多很多次沒有命中的 channel 讀取，若不是自己要的還得把數值還回去。做個比喻，就像老闆雇用員工吧，因為不具備識人能力，都先雇用再說，不對再趕走。（只是比喻，如有雷同，純屬巧合）</p><p>受限於 channel 的性質，看了就會改變內容，所以若沒有命中就多了「還回去」的動作，無法如同 get 存取子一樣只讀不寫。</p><h4 id="自循環-外部啟動注意事項">自循環 &amp; 外部啟動注意事項</h4><p>首先，這個循環是從 0 開始，沒有人交棒給 0，所以 <code>main()</code> 要自己丟。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fizzbuzz.streamBaton &lt;- <span class="number">0</span> <span class="comment">//啟動交棒</span></span><br></pre></td></tr></table></figure><p>再來，本題不像之前有清楚的交接棒順序，不預設哪一個 goroutine 會收尾，所以需要用 <code>sync.WaitGroup</code> 同步 4 個 goroutine 結束時間。</p><p>最後，由於最後一個 print 交出去的棒子沒 goroutine 接，所以要記得關閉通道，否則在交棒點會發生 deadlock。（你想知道後果的話，可以在下面原始碼自行把 close 這行註解掉看看）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(fizzbuzz.streamBaton)</span><br></pre></td></tr></table></figure><h4 id="交接棒流程：PrintLoop-視角">交接棒流程：PrintLoop() 視角</h4><p>這一次採用去中心化的交棒決策，所以每一個 goroutine 的流程都是相同的，因此我將各自的「整除條件」<code>PassCondition(i int)bool</code>與「字串輸出」<code>PrintString(i int)</code>取出，以下列程式碼 <code>PrintFizz()</code> 為例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FizzBuzz)</span> <span class="title">PrintFizz</span><span class="params">()</span></span> &#123;</span><br><span class="line">PassCondition := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> (<span class="number">0</span> == i%<span class="number">3</span>) &amp;&amp; (<span class="number">0</span> != i%<span class="number">5</span>) &#125;</span><br><span class="line">PrintString := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; fmt.Printf(<span class="string">&quot;Fizz(%d), &quot;</span>, i) &#125;</span><br><span class="line"></span><br><span class="line">this.PrintLoop(PassCondition, PrintString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的 <code>PrintBuzz()</code>、<code>PrintFizzBuzz()</code>、<code>PrintNumber()</code> 也都比照辦理。剩下都抽象為 <code>PrintLoop()</code> 以達到程式碼的 DRY，如下列程式碼：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FizzBuzz)</span> <span class="title">PrintLoop</span><span class="params">(passCondition <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>, <span class="title">printString</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> this.wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= this.n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> passCondition(i) &#123;</span><br><span class="line">nextNum := &lt;-this.streamBaton <span class="comment">//接棒</span></span><br><span class="line"><span class="keyword">if</span> i == nextNum &#123;</span><br><span class="line">printString(i)</span><br><span class="line">this.streamBaton &lt;- i + <span class="number">1</span> <span class="comment">//交棒</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.streamBaton &lt;- nextNum <span class="comment">//把數字還回去</span></span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for loop 會獨自判斷 0~n 每一個數字是否滿足自己要輸出的條件？</p><ol><li>若滿足，就去公共的 channel <code>streamBaton</code> 裡頭看看，有沒有剛好與 i 相同的數字？<ul><li>若有，表示有某未知 goroutine 交棒給自己了，便可以輸出。輸出以後要交棒，只知道下一棒的數字會+1，但並不知道誰接棒？反正把棒子丟回去公共的 channel <code>streamBaton</code> 讓該接棒的自己接棒。</li><li>若無，表示這次讀取沒命中、表示自己還沒接到棒，要把數字再寫回 channel 讓應該接這一棒的 goroutine 可以讀取到這筆資訊。<code>i--</code> 使 for loop 不會前進，繼續原地等待接棒。</li></ul></li><li>動作完成後，要執行 <code>runtime.Gosched()</code>，使自己不會獨佔 CPU，令其他 goroutine 有機會可以動作。</li></ol><h3 id="3-「不要透過共享來通訊，而要透過通訊來共享」">3.「不要透過共享來通訊，而要透過通訊來共享」</h3><p>過去幾次解題都用 unbuffered channel 的原因是，並沒有要共享什麼資料，就只要在 goroutine 之間交接棒，這個棒子上不需要帶其他訊息，因此 channel 用的也比較多，因為「交棒給誰？」的訊息用多個不同 topic 的 channel 區別。</p><p>這一次採用 buffered channel，是因為不只要交接棒了，還要透過一個 int 來指定下一個交接對象，這就是「透過通訊來共享」。</p><p>當我們要把一件事講清楚，除了講「應該是什麼」，最好也把「不應該是什麼」說明白，正反例都有更有助於建立清晰的認知。</p><p>那麼，要是我就故意反著做，硬要「透過共享來通訊」呢？很簡單，把 <code>chan int</code> 改成 <code>int</code>，其他部分做些相應修改就是了。兩個版本的程式碼都會放在下面的 The Go Playground 連結。</p><p>但是這兩種方法，在本題的執行結果卻完全相同！花費時間也沒有明顯差異。所以「透過通訊來共享」的優越性到底在哪裡？或許本題的要求不夠嚴苛，不足以展示出差異，而筆者自己也學藝不精，尚未參透。如果有讀者能說得清楚，歡迎在本文底下留言，筆者會非常感謝你。</p><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p>「透過通訊來共享」版本（使用 chan int）:<br><a href="https://play.golang.org/p/nHZtkI-pGs5">https://play.golang.org/p/nHZtkI-pGs5</a></p><p>「透過共享來通訊」版本（使用 int）:<br><a href="https://play.golang.org/p/92wshFYlPG3">https://play.golang.org/p/92wshFYlPG3</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/FizzBuzzMultithreaded%E7%A4%BA%E6%84%8F%E5%9C%9620200223.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次將會示範 goroutine 教學中常講到的「不要透過共享來通訊，而要透過通訊來共享」。&lt;/p&gt;
&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>select-case-default 忘記讓出 CPU 的地雷，只在我電腦上能跑的程式</title>
    <link href="https://mosdeo.github.io/2020/01/21/select-case-default%E5%BF%98%E8%A8%98%E8%AE%93%E5%87%BACPU%E7%9A%84%E5%9C%B0%E9%9B%B7%EF%BC%8C%E5%8F%AA%E5%9C%A8%E6%88%91%E9%9B%BB%E8%85%A6%E4%B8%8A%E8%83%BD%E8%B7%91%E7%9A%84%E7%A8%8B%E5%BC%8F/"/>
    <id>https://mosdeo.github.io/2020/01/21/select-case-default%E5%BF%98%E8%A8%98%E8%AE%93%E5%87%BACPU%E7%9A%84%E5%9C%B0%E9%9B%B7%EF%BC%8C%E5%8F%AA%E5%9C%A8%E6%88%91%E9%9B%BB%E8%85%A6%E4%B8%8A%E8%83%BD%E8%B7%91%E7%9A%84%E7%A8%8B%E5%BC%8F/</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-01-22T06:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>這一篇其實是為了要補充上一篇<a href="https://mosdeo.github.io/2020/01/21/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintZeroEvenOdd/">「LeetCode Concurrency Go 語言詳解：Print Zero Even Odd」</a>沒寫到的細節，但所要解釋的概念，是針對 mulit-channel 管理上可能會犯的錯誤，與 LeetCode 比較沒關係，只是我剛好在解這一題 LeetCode 時學到的，所以最後決定將這部分獨立成一篇文章介紹。</p><p>為什麼說是地雷？當程式在自己的電腦上正常，我會很容易以為自己是對的，而且這個現象與作業系統的排程細節有關，很難找一個明確的環境原因。</p><h2 id="補充：我踩到的-select-case-default-地雷">補充：我踩到的 select-case-default 地雷</h2><p>你可以看到，我的解題程式碼 default 那段是這麼寫的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line">runtime.Gosched()</span><br><span class="line"><span class="comment">//&lt;-time.After(time.Microsecond)</span></span><br><span class="line">i--</span><br></pre></td></tr></table></figure><p>以上其實是被高人「指點」後的。原本是這麼寫：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line">i--</span><br></pre></td></tr></table></figure><p>這樣在我的 MacBook 依然正常，但是拿到 The Go Playground 上面就掛了，你可以自己修改程式碼（那篇解題文章最後有程式連結），在 The Go Playground 上試看看會怎樣？</p><hr><p>原因是，雖然 select-case-default 會隨機均勻的嘗試每一個 case-default，但是並不會主動把 CPU 控制權交出去，需要用 <code>runtime.Gosched()</code> 或 <code>&lt;-time.After(time.Microsecond)</code> 把 CPU 讓出給其他 goroutine。否則，其他的 goroutine 將可能沒有機會動作。</p><p>C# 裡的 <code>Application.DoEvents()</code> 也是一樣的意思，讓別的事件有機會被觸發。</p><hr><p>那為什麼我的 MacBook 正常跑完？難道是 CPU 使用數量限制嗎？我們來看看這兩個平台可用的邏輯處理器數量：</p><ul><li>The Go Playground: runtime.NumCPU=1</li><li>MacBook Air 2018:  runtime.NumCPU=4</li></ul><p>好的，我的 MacBook 果然有比較多邏輯處理器可用，但也不足以說明這就是原因。</p><p>於是，我索性在筆電上的程式碼開頭加上一行 <code>runtime.GOMAXPROCS(1)</code> 限制此程式與 The Go Playground 一樣，只能用一個邏輯 CPU。結果，字出來是變慢了，好像古老的打字機那樣，但也是順利正確的跑完了，無法重現 The Go Playground 上發生的錯誤。所以這樣的 bug，真的很難在不同平台上重現，是很不容易發現的地雷。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這一篇其實是為了要補充上一篇&lt;a href=&quot;https://mosdeo.github.io/2020/01/21/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintZeroEvenOdd/&quot;</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：Print Zero Even Odd</title>
    <link href="https://mosdeo.github.io/2020/01/20/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintZeroEvenOdd/"/>
    <id>https://mosdeo.github.io/2020/01/20/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintZeroEvenOdd/</id>
    <published>2020-01-20T16:00:00.000Z</published>
    <updated>2020-02-10T01:50:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我寫的第三題 LeetCode Concurrency Go 語言詳解，技術比前面兩題都要複雜。為了解釋到我自認夠清楚，寫的時間多花了好幾倍（1x = 2hr）。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/print-zero-even-odd/">https://leetcode.com/problems/print-zero-even-odd/</a></p><h2 id="本題題目">本題題目</h2><blockquote><p>The same instance of ZeroEvenOdd will be passed to three different threads:</p></blockquote><p>同一個 instance <code>ZeroEvenOdd</code> 會被傳到三個 thread 裡面:</p><blockquote><p>Thread A will call zero() which should only output 0’s.<br>Thread B will call even() which should only ouput even numbers.<br>Thread C will call odd() which should only output odd numbers.</p></blockquote><p>Thread A 將會呼叫 <code>zero()</code> 並且只會輸出 0<br>Thread B 將會呼叫 <code>even()</code> 並且只會輸出偶數<br>Thread C 將會呼叫 <code>odd()</code> 並且只會輸出奇數</p><blockquote><p>Each of the threads is given a printNumber method to output an integer. Modify the given program to output the series 010203040506… where the length of the series must be 2n.</p></blockquote><p>每一個 thread 都會被傳入一個 <code>printNumber()</code> 以輸出一個整數。<br>修改已給的程式碼，使其輸出序列為 010203040506…，該序列長度必須為 2n。</p><h2 id="本題考核難點？">本題考核難點？</h2><p>在一個未知長度的序列中，依照「0-奇數-0-偶數」的順序將數字印出，且一種元素只能由一個執行緒印出，代表各個執行緒之間要依照這個數列的規則溝通。</p><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 順序控制的能力。</p><p>與前面幾題不同的是，這一題最後工作的 thread 具有不確定性，視數列最後一個元素為奇數或偶數來決定，這點小小的提高了難度。</p><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><p>本題採用五個 unbuffered channel，並且是 <code>ZeroEvenOdd</code> 的成員變數。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ZeroEvenOdd <span class="keyword">struct</span> &#123;</span><br><span class="line">n                <span class="keyword">int</span></span><br><span class="line">streamEvenToZero <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamOddToZero  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamZeroToEven <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamZeroToOdd  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamZeroToEnd  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zeo = &amp;ZeroEvenOdd&#123;</span><br><span class="line">n:                testNum,</span><br><span class="line">streamEvenToZero: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">streamOddToZero:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">streamZeroToEven: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">streamZeroToOdd:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">streamZeroToEnd:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位分別是:</p><ul><li><code>streamEvenToZero</code>: <code>Even()</code> 交棒給 <code>Zero()</code></li><li><code>streamOddToZero</code>: <code>Odd()</code> 交棒給 <code>Zero()</code></li><li><code>streamZeroToEven</code>: <code>Zero()</code> 交棒給 <code>Even()</code></li><li><code>streamZeroToOdd</code>: <code>Zero()</code> 交棒給 <code>Odd()</code></li><li><code>streamZeroToEnd</code>: <code>Zero()</code> 交棒給啟動它的 goroutine</li></ul><h3 id="2-五個-goroutine-之間，如何交接棒？">2. 五個 goroutine 之間，如何交接棒？</h3><h4 id="自循環-外部啟動注意事項">自循環 &amp; 外部啟動注意事項</h4><p>以前的文章說過，由於本題解法採用各個 goroutine 彼此循環交棒的方式，因此不能自行啟動，需要外界給訊號，所以在包住一整題的 <code>PrintZeroEvenOdd()</code> 執行各個 <code>goroutine</code> 同時以 <code>zeo.streamEvenToZero &lt;- struct&#123;&#125;&#123;&#125;</code> 作為起頭的火種 ，讓 <code>main()</code> 假裝自己是 <code>Even()</code> 交棒給 <code>Zero()</code>，以啟動交接棒循環。具體程式碼如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; zeo.streamEvenToZero &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;() <span class="comment">//給起頭的火種</span></span><br><span class="line"><span class="keyword">go</span> zeo.Zero(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Even(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Odd(PrintNumber)</span><br></pre></td></tr></table></figure><p>要特別注意的是，這個「啟動火種」也要寫成 goroutine，否則會由於執行當下尚未等到消費者「出世」，發生 deadlock！</p><p>另外一種不用 goroutine 啟動的做法，也可以讓消費者先「出世」，在 goroutine 的阻塞中等待時，再給「啟動火種」。具體程式碼如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> zeo.Zero(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Even(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Odd(PrintNumber)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; zeo.streamEvenToZero &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;() <span class="comment">//給起頭的火種</span></span><br></pre></td></tr></table></figure><h4 id="交接棒流程：Zero-視角">交接棒流程：Zero() 視角</h4><p>中心化：由 <code>Zero()</code> 做控管中心，遍歷 0 to n 每一個數字，印完自己責任該印的 “0” 以後，根據數字性質決定要把棒子交給 <code>Even()</code> 或 <code>Odd()</code>。此處會用到 select-case-default。具體程式碼如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ZeroEvenOdd)</span> <span class="title">Zero</span><span class="params">(printNumber <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; this.n; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-this.streamOddToZero:</span><br><span class="line">printNumber(<span class="number">0</span>)</span><br><span class="line">this.streamZeroToEven &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-this.streamEvenToZero:</span><br><span class="line">printNumber(<span class="number">0</span>)</span><br><span class="line">this.streamZeroToOdd &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">runtime.Gosched()</span><br><span class="line"><span class="comment">//&lt;-time.After(time.Microsecond)</span></span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> == this.n%<span class="number">2</span> &#123;</span><br><span class="line">&lt;-this.streamEvenToZero <span class="comment">//等待 Even() 結束，自己再結束</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&lt;-this.streamOddToZero <span class="comment">//等待 Odd() 結束，自己再結束</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>雖然順序都是固定的，但在此先假裝 <code>Zero()</code> 並不知道誰會交棒給自己？所以 <code>Zero()</code> 交棒（send to chan）以後，就會在 for-select 裡無窮迴圈，每一次 select{} 都會隨機選擇一個 case 或 default，也就是以亂槍打鳥的方式 polling 是誰交棒給自己？</p><blockquote><p>謎之聲：「難道有不是中心化的流程嗎？」，有喔！我解決「DiningPhilosophers」這一題用的就是去中心化方法，但目前還沒寫那一題詳解。</p></blockquote><h4 id="交接棒流程：Even-Odd-視角">交接棒流程：Even() &amp; Odd() 視角</h4><p>對於 <code>Even()</code> 與 <code>Odd()</code> 來說，流程很固定，只有 <code>Zero()</code> 會交棒給自己，印完數字後，也只需要交棒給同樣的 <code>Zero()</code> ，一種「哪裡來，就哪裡去」的概念。</p><p>唯一比較複雜的部分，就是數字「遞增」與「終點」的控制：</p><ul><li>「遞增」每一次都是 += 2，不必解釋。</li><li>「終點」一開始就算好題目下的奇數上限、偶數上限，算法看程式碼也很清楚了，不解釋。超過終點就直接結束。</li></ul><p>具體程式碼如下（太相似，故此處只放 <code>Even()</code> 舉例）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ZeroEvenOdd)</span> <span class="title">Even</span><span class="params">(printNumber <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">evenUpper := this.n - this.n%<span class="number">2</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;evenUpper:&quot;, evenUpper)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= evenUpper; &#123;</span><br><span class="line">&lt;-this.streamZeroToEven</span><br><span class="line">printNumber(i)</span><br><span class="line">i += <span class="number">2</span></span><br><span class="line">this.streamEvenToZero &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收尾之一：為什麼要-Zero-善後？">收尾之一：為什麼要 <code>Zero()</code> 善後？</h4><p>由於題目的關係，<code>Even()</code> 或 <code>Odd()</code> 其中一個，都有可能是最後印出字元的 goroutine，若讓這兩者去收尾，流程上的不確定性比較大。因此，幾經考慮後，還是決定讓 <code>Zero()</code> 去收尾。</p><p>讓 <code>Zero()</code> 去收尾的套路，之前的詳解也寫過，就是先 return 的 goroutine 最後都要 send to chan 到負責收尾的 goroutine，收尾 goroutine 在最後一一將這些 chan 都 receive 掉。</p><p>但由於本題特性，可由題目給定數字的奇偶判斷，<code>Zero()</code> 會從哪個 channnel 收到收尾訊號？因此在 <code>Zero()</code> 最後段的 receive，是以奇偶數判斷要在何處等待。具體的局部程式碼如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> == this.n%<span class="number">2</span> &#123;</span><br><span class="line">&lt;-this.streamEvenToZero <span class="comment">//等待 Even() 結束，自己再結束</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&lt;-this.streamOddToZero <span class="comment">//等待 Odd() 結束，自己再結束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收尾之二：代替-sync-WaitGroup-Wait-的「chan-receive-阻塞法」">收尾之二：代替 sync.WaitGroup.Wait() 的「chan receive 阻塞法」</h4><p>主程式為了等待 goroutine 都結束才往下的同步情況，往往會用 <code>sync.WaitGroup.Wait()</code>。<br>根據本文前面所介紹，我已經將流程結束的不確定性減少，使得一定會由 <code>Zero()</code> 負責收尾，因此只要在主程式阻塞一個 chan receive，由 <code>Zero()</code> 結束前 send 一下，便可以將主程式打通，繼續往下。</p><p>具體的局部程式碼如下：</p><p>goroutine <code>Zero()</code> 結束前 send 一下，交棒出去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ZeroEvenOdd)</span> <span class="title">Zero</span><span class="params">(printNumber <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="comment">//.....略過多行</span></span><br><span class="line">this.streamZeroToEnd &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主程式啟動完其他 goroutine 之後，阻塞一個 chan receive，等待被 <code>Zero()</code> 打通，繼續往下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> zeo.Zero(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Even(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Odd(PrintNumber)</span><br><span class="line">&lt;-zeo.streamZeroToEnd <span class="comment">//等待 Zero() 送出結束訊號</span></span><br></pre></td></tr></table></figure><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p><a href="https://play.golang.org/p/K5ZpQsHxlfN">https://play.golang.org/p/K5ZpQsHxlfN</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/PrintZeroEvenOdd%E7%A4%BA%E6%84%8F%E5%9C%9620200121.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我寫的第三題 LeetCode Concurrency Go 語言詳解</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：Print In Order</title>
    <link href="https://mosdeo.github.io/2020/01/18/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintInOrder/"/>
    <id>https://mosdeo.github.io/2020/01/18/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintInOrder/</id>
    <published>2020-01-18T16:00:00.000Z</published>
    <updated>2020-02-10T01:50:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我試水溫的第二篇。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/print-in-order/">https://leetcode.com/problems/print-in-order/</a></p><h2 id="本題考核點？">本題考核點？</h2><p>指定各種不同順序執行 <code>First()</code>, <code>Second()</code>, <code>Third()</code> 三個 goroutine，但三者都必須以不變順序印出字串，印出順序不受順序執行影響。</p><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 順序控制的能力。</p><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><p>本題採用三個 unbuffered channel，並且串在一個 slice 裡。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make an array of unbuffered</span></span><br><span class="line"><span class="keyword">var</span> streamSync [<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> streamSync &#123;</span><br><span class="line">streamSync[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分別是:</p><ul><li><code>streamSync[0]</code>: <code>First()</code> 交棒給 <code>Second()</code></li><li><code>streamSync[1]</code>: <code>Second()</code> 交棒給 <code>Third()</code></li><li><code>streamSync[2]</code>: <code>Third()</code> 交棒給 <code>PrintInOrder()</code></li></ul><h3 id="2-三個-或說四個-goroutine-之間，如何交接棒？">2. 三個(或說四個) goroutine 之間，如何交接棒？</h3><p>一開始由 <code>PrintInOrder()</code> 依照指定順序啟動三個 goroutine。</p><p>再看這三個 goroutine，只有 <code>First()</code> 可以不受限執行 Print，其餘都必須等待各自的 <code>streamSync[i]</code> 訊號，因此可以保證 “First” 先被印出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(streamSync [3]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;First&quot;</span>)</span><br><span class="line">streamSync[<span class="number">0</span>] &lt;- <span class="literal">nil</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Second</span><span class="params">(streamSync [3]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&lt;-streamSync[<span class="number">0</span>]</span><br><span class="line">fmt.Print(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line">streamSync[<span class="number">1</span>] &lt;- <span class="literal">nil</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Third</span><span class="params">(streamSync [3]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&lt;-streamSync[<span class="number">1</span>]</span><br><span class="line">fmt.Print(<span class="string">&quot;Third&quot;</span>)</span><br><span class="line">streamSync[<span class="number">2</span>] &lt;- <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>當 “First” 先被印出之後，交棒給 <code>streamSync[0]</code>，然後…</p><ul><li>被 <code>streamSync[0]</code> 卡住的 <code>Second()</code> 就可以印出 “Second”</li><li>被 <code>streamSync[1]</code> 卡住的 <code>Third()</code> 繼續等待訊號</li><li>被 <code>streamSync[2]</code> 卡住的 <code>PrintInOrder()</code> 繼續等待訊號</li></ul></li><li><p>當 “Second” 繼續被印出之後，交棒給 <code>streamSync[1]</code>，然後…</p><ul><li>被 <code>streamSync[1]</code> 卡住的 <code>Third()</code> 就可以印出 “Third”</li><li>被 <code>streamSync[2]</code> 卡住的 <code>PrintInOrder()</code> 繼續等待訊號</li></ul></li><li><p>當 “Third” 最後被印出之後，交棒給 <code>streamSync[2]</code>，然後…</p><ul><li>被 <code>streamSync[2]</code> 卡住的 <code>PrintInOrder()</code> 就可以往下執行，最後程式順利結束。</li></ul></li></ol><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p>本題解答程式碼已經窮舉這三個 goroutine 所有啟動順序。</p><p><a href="https://play.golang.org/p/cklu-vaxF6w">https://play.golang.org/p/cklu-vaxF6w</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/PrintInOrder%E7%A4%BA%E6%84%8F%E5%9C%9620200119.JPG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我試水溫的第二篇。&lt;/p&gt;
&lt;h2 id=&quot;本題-LeetCode-連</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：Print FooBar Alternately</title>
    <link href="https://mosdeo.github.io/2020/01/15/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintFooBarAlternately/"/>
    <id>https://mosdeo.github.io/2020/01/15/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintFooBarAlternately/</id>
    <published>2020-01-15T16:00:00.000Z</published>
    <updated>2020-02-10T01:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我試水溫的第一篇。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/print-foobar-alternately/">https://leetcode.com/problems/print-foobar-alternately/</a></p><h2 id="本題考核點？">本題考核點？</h2><p>指定次數交替執行 <code>printFoo()</code> 與 <code>printBar()</code>。若任由兩個 goroutine 分別各自 print，不能保證其結果一定會互相交錯。</p><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 來回交錯順序控制的能力。</p><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><p>本題採用三個 unbuffered channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FooBar <span class="keyword">struct</span> &#123;</span><br><span class="line">n              <span class="keyword">int</span></span><br><span class="line">streamFooToBar <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamBarToFoo <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamEnd      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分別是:</p><ul><li><code>streamFooToBar</code>: <code>Foo()</code> 交棒給 <code>Bar()</code></li><li><code>streamBarToFoo</code>: <code>Bar()</code> 交棒給 <code>Foo()</code></li><li><code>streamEnd</code>: 結束訊號</li></ul><h3 id="2-Foo-與-Bar-如何交接棒？">2. <code>Foo()</code> 與 <code>Bar()</code> 如何交接棒？</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FooBar)</span> <span class="title">Foo</span><span class="params">(printFoo <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; this.n; &#123;</span><br><span class="line"><span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">&lt;-this.streamBarToFoo</span><br><span class="line">printFoo()</span><br><span class="line">i++</span><br><span class="line">this.streamFooToBar &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-this.streamBarToFoo <span class="comment">//等待 Bar() 印完最後一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根據設定次數 n 重複執行</li><li>每一輪都要得到 <code>Bar()</code> 交出棒，才會執行 <code>printFoo()</code> 以印出字串</li><li>印出字串後，以 <code>this.streamFooToBar &lt;- struct&#123;&#125;&#123;&#125;</code> 交棒給 <code>Bar()</code></li></ul><p>下方的 <code>Bar()</code> 也是一樣的道理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FooBar)</span> <span class="title">Bar</span><span class="params">(printBar <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; this.n; &#123;</span><br><span class="line"><span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">&lt;-this.streamFooToBar</span><br><span class="line">printBar()</span><br><span class="line">i++</span><br><span class="line">this.streamBarToFoo &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.streamEnd &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Foo-與-Bar-如何收尾？">3. <code>Foo()</code> 與 <code>Bar()</code> 如何收尾？</h3><p>這裡要特別注意的是，<code>Foo()</code> 與 <code>Bar()</code> 只有差異在最後一行，用意是什麼？</p><p>多個 goroutine 用 unbuffered channel 互相交接棒，會有一個尷尬的情況，就是互為消費者、又互為生產者，因此先 return 的 goroutine 沒事，但是後 return 的 goroutine 會由於消費者消失，send to channel 的時候發生 Deadlock。</p><p>根據本題遊戲規則， <code>printBar()</code> 一定要比 <code>printFoo()</code> 晚執行，因此不做特別處理的話，會在 <code>Bar()</code> 試圖做最後一次交棒時，由於消費者消失發生 Deadlock。</p><p>我的應對方式，就是讓 <code>Foo()</code> return 前做一次無特別作用的接棒，這樣就可以避免 <code>Bar()</code> return 前找不到消費者的問題。</p><h3 id="4-自循環啟動">4. 自循環啟動</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fooBar.streamBarToFoo &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//啟動</span></span><br></pre></td></tr></table></figure><p>前面說過，本題解法採用 <code>Foo()</code> 與 <code>Bar()</code> 彼此循環交棒的方式，因此不能自行啟動，需要外界給訊號，所以在 <code>main()</code> 執行各個 <code>goroutine</code> 以後以 <code>fooBar.streamBarToFoo &lt;- struct&#123;&#125;&#123;&#125;</code> ，讓 <code>main()</code> 假裝自己是 <code>Bar()</code> 交棒給 <code>Foo()</code>，以啟動交接棒循環。</p><h3 id="5-特別條件下，用-unbuffered-channel-取代-sync-WaitGroup">5. 特別條件下，用 unbuffered channel 取代 sync.WaitGroup</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-fooBar.streamEnd                  <span class="comment">//as wg.Wait()</span></span><br></pre></td></tr></table></figure><p>為了等待多個 goroutine 都結束再往下，一般來說用 <code>sync.WaitGroup.Wait()</code> 是標準做法。但這一題還有更輕量的方法。</p><p>雖然這一題是 Concurrency，但是各個 goroutine 的結束順序已經被定死，我們很清楚知道誰負責收尾，所以讓負責收尾的 goroutine send to unbuffered channel，然後在 <code>main()</code> read 掉，這樣就不需要使用 sync.WaitGroup</p><p>執行各個 goroutine 以後，<code>main()</code> 會由於 <code>&lt;-fooBar.streamEnd</code> 還沒有被傳入而被卡住，這就相當於 <code>sync.WaitGroup.Wait()</code> 的作用了。</p><p>由於是 <code>Bar()</code> 會做最後一次有意義的執行，因此讓 <code>Bar()</code> return 之前執行 <code>this.streamEnd &lt;- struct&#123;&#125;&#123;&#125;</code>，這就相當於交棒給 <code>main()</code>， <code>main()</code> 終於可以從被卡住的 <code>&lt;-fooBar.streamEnd</code> 往下（因為終於有東西可以讀），就像便秘了三天突然暢通一樣！</p><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p><a href="https://play.golang.org/p/YsXKHbxpOCT">https://play.golang.org/p/YsXKHbxpOCT</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/PrintFooBarAlternately%E7%A4%BA%E6%84%8F%E5%9C%9620200116.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我試水溫的第一篇。&lt;/p&gt;
&lt;h2 id=&quot;本題-LeetCode-連</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>解決在 macOS 上安裝 OpenCV 遇到「‘opencv2/opencv.hpp’ file not found」地雷</title>
    <link href="https://mosdeo.github.io/2019/10/09/%E5%9C%A8%20macOS%20%E4%B8%8A%E5%AE%89%E8%A3%9D%20OpenCV%20%E9%81%87%E5%88%B0%E7%9A%84%E5%9C%B0%E9%9B%B7/"/>
    <id>https://mosdeo.github.io/2019/10/09/%E5%9C%A8%20macOS%20%E4%B8%8A%E5%AE%89%E8%A3%9D%20OpenCV%20%E9%81%87%E5%88%B0%E7%9A%84%E5%9C%B0%E9%9B%B7/</id>
    <published>2019-10-09T16:00:00.000Z</published>
    <updated>2019-10-10T11:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>安裝 OpenCV 一直都是堪稱玄學的技術，猶記得我大四第一次入門花了兩週才安裝成功，其中一個原因是我自己對「編譯、連結、載入、執行」不熟悉，這也是我技能樹有待補強的地方。</p><p>是說，這麼多年過去了，Windows 和 Linux 上我也安裝了無數次，EmguCV 也搞得定，換到上 macOS 仍須鬼打牆一整天才找到解方。</p><p>錯誤如下：</p><blockquote><p>fatal error: ‘opencv2/opencv.hpp’ file not found</p></blockquote><hr><h2 id="檢查編譯設定">檢查編譯設定</h2><p>我又反覆檢查 VSCode 中 task.json 的編譯設定，確認給出的路徑裡的確有 libs</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;clang++&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">            <span class="comment">//&quot;main(regression_demo).cpp&quot;,</span></span><br><span class="line">            <span class="comment">//&quot;main(classification_demo).cpp&quot;,</span></span><br><span class="line">            <span class="string">&quot;libLKYDeepNN/InputLayer.cpp&quot;</span>,<span class="string">&quot;libLKYDeepNN/HiddenLayer.cpp&quot;</span>,<span class="string">&quot;libLKYDeepNN/OutputLayer.cpp&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-Wall&quot;</span>,</span><br><span class="line">            <span class="comment">//&quot;-v&quot;,</span></span><br><span class="line">            <span class="string">&quot;-pthread&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-I /usr/local/Cellar/opencv/4.1.1_2/lib/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-lopencv_core&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-lopencv_highgui&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-lopencv_imgproc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-std=c++11&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-Ofast&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">            <span class="string">&quot;LKYDeepNN&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="透過-IntelliSense-驗證-includePath-正確性">透過 IntelliSense 驗證 includePath 正確性</h2><p>而我在 c_cpp_properties.json 中給 IntelliSense 的 includePath 是這樣，</p><blockquote><p>/usr/local/Cellar/opencv/4.1.1_2/include/opencv4/**</p></blockquote><p>IntelliSense 能正確識別叫出 namespace cv 底下的東西，所以也驗證了是正確的。</p><hr><h2 id="失敗：改-include">失敗：改 include</h2><p>如果我把 include 從這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>改成這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv4/opencv2/opencv.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>的話，「fatal error: ‘opencv2/opencv.hpp’ file not found」會消失，但是換成其他的更深層的 OpenCV hpp 找不到 include。</p><p>別忘了要改回來。</p><hr><h2 id="成功解決：soft-link">成功解決：soft link</h2><p>最後發現，在 /usr/local/inlcude 建立一個 softlink 指向 opencv2，就可以成功編譯。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/include/opencv4/opencv2 opencv2</span><br></pre></td></tr></table></figure><p>是解決了，但我依然說不清楚誰去參考了「/usr/local/include/opencv2」因此得到錯誤或正確的結果。</p><p>參考來源：https://blog.csdn.net/a13602955218/article/details/101625857</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安裝 OpenCV 一直都是堪稱玄學的技術，猶記得我大四第一次入門花了兩週才安裝成功，其中一個原因是我自己對「編譯、連結、載入、執行」不熟悉，這也是我技能樹有待補強的地方。&lt;/p&gt;
&lt;p&gt;是說，這麼多年過去了，Windows 和 Linux 上我也安裝了無數次，EmguCV</summary>
      
    
    
    
    
    <category term="OpenCV" scheme="https://mosdeo.github.io/tags/OpenCV/"/>
    
    <category term="Mac" scheme="https://mosdeo.github.io/tags/Mac/"/>
    
    <category term="除錯" scheme="https://mosdeo.github.io/tags/%E9%99%A4%E9%8C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Charlotte 碳排放評估案例</title>
    <link href="https://mosdeo.github.io/2019/03/19/Charlotte%E7%A2%B3%E6%8E%92%E6%94%BE%E8%A9%95%E4%BC%B0%E6%A1%88%E4%BE%8B/"/>
    <id>https://mosdeo.github.io/2019/03/19/Charlotte%E7%A2%B3%E6%8E%92%E6%94%BE%E8%A9%95%E4%BC%B0%E6%A1%88%E4%BE%8B/</id>
    <published>2019-03-19T16:00:00.000Z</published>
    <updated>2019-09-23T02:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>注意：本文為隨興、無組織的讀書筆記，如果你看不懂我寫什麼是正常的。我只是想記錄一個數據分析的案例。</p><h2 id="摘要">摘要</h2><p>本文為闡述美國環保局對北卡羅萊納州最大的城市－Charlotte，所做的碳排放模擬，想了解＂精明增長（Smart Growth）＂與＂蔓延增長＂兩種土地利用策略對交通設施的變化，進而了解對碳排放的影響。</p><h2 id="原始數據與處理-1-社區特徵聚類">原始數據與處理(1)-社區特徵聚類</h2><ul><li>步行可行性</li><li>可達性</li><li>地塊</li><li>工業區域</li><li>城市屬性值</li></ul><p>將 5 種特徵以 K-means 聚類為 8 種社區類型。</p><h2 id="原始數據與處理-2-人口預測">原始數據與處理(2)-人口預測</h2><ul><li>2003 Woods &amp; Poole 經濟學資料庫</li><li>使用區域預測模型(?)預測到2030年</li><li>3 種外插法預測 2030~2050<ul><li>2029~2030 一次導數</li><li>1991~2030 二次導數</li><li>前兩種方法的綜合，使用 2030 年的二次導數直推到 2050 年</li></ul></li><li>最後，對三種外插法的結果平均</li></ul><h2 id="名詞解釋">名詞解釋</h2><ul><li>TOD(Transit-Oriented Development)：以公共交通为导向的发展</li><li>基礎年：2010 年</li><li>mph：英里每小时。1 mph = 0.44704 m/s</li><li>集計處理(Aggregate)：基於 GIS 單位的 downsample，例如將單位由＂區＂擴大到＂縣市＂。</li><li>美國環保局(EPA)排放因素模組－MOBILE6<ul><li>採用特徵：燃油類型、引擎技術、路段平均速度、設施類型(高速公路、主幹道)、排放控制標準、檢查與維修、環境條件(溫度、濕度、大氣壓力)、車型(輕型車、重型車、公車)與車齡</li></ul></li></ul><h2 id="模擬至2050年的結果">模擬至2050年的結果</h2><ul><li><p>就業（兩方案總就業變化量相同）</p><ul><li>蔓延增長：由市中心向外擴散</li><li>精明增長：由市中心與公車站點向外擴散，形成多中心格局</li></ul></li><li><p>住宅（兩方案總住宅變化量相同）</p><ul><li>蔓延增長：由市中心向外擴散</li><li>精明增長：</li></ul></li><li><p>車輛行駛里程</p><ul><li>蔓延增長/基礎年=97.5%</li><li>精明增長/基礎年=86.7%</li></ul></li><li><p>路網平均行駛速度</p><ul><li>(基礎年,蔓延增長,精明增長) =(42, 33, 35)mph</li></ul></li><li><p>交通行為對比(精明增長：蔓延增長)</p><ul><li>公車乘客里程數：高50%</li><li>小汽車乘客里程數：低6.3%</li><li>步行量：高54%</li><li>公車供給量：多60%</li></ul></li></ul><h2 id="出處">出處</h2><ul><li>宋彦, and 陈燕萍. “城市规划评估指引.” 中国建筑工业出版社(2012). 第十章:信息技术在国外规划评估中的应用。</li><li><a href="http://www.paper.edu.cn/scholar/showpdf/MUT2MN1INTT0Ixxh">宋彦, et al. “城市空间结构对 PM2. 5 的影响——美国夏洛特汽车排放评估项目的借鉴和启示.” 城市规划 5 (2014): 9-14.</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注意：本文為隨興、無組織的讀書筆記，如果你看不懂我寫什麼是正常的。我只是想記錄一個數據分析的案例。&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文為闡述美國環保局對北卡羅萊納州最大的城市－Charlotte，所做的碳排放模擬，想了解＂精明增長（Smart Gro</summary>
      
    
    
    
    
    <category term="GIS" scheme="https://mosdeo.github.io/tags/GIS/"/>
    
    <category term="地理資訊系統" scheme="https://mosdeo.github.io/tags/%E5%9C%B0%E7%90%86%E8%B3%87%E8%A8%8A%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="機器學習" scheme="https://mosdeo.github.io/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
  </entry>
  
  <entry>
    <title>同事怎麼還不commit🤬別生氣！你們可能踩到 SVN 的大小寫地雷</title>
    <link href="https://mosdeo.github.io/2019/03/13/%E5%90%8C%E4%BA%8B%E6%80%8E%E9%BA%BC%E9%82%84%E4%B8%8D%20commit%EF%BC%81%E5%88%A5%E7%94%9F%E6%B0%A3%EF%BC%8C%E4%BD%A0%E5%8F%AF%E8%83%BD%E8%B8%A9%E5%88%B0%20SVN%20%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%AF%AB%E5%9C%B0%E9%9B%B7/"/>
    <id>https://mosdeo.github.io/2019/03/13/%E5%90%8C%E4%BA%8B%E6%80%8E%E9%BA%BC%E9%82%84%E4%B8%8D%20commit%EF%BC%81%E5%88%A5%E7%94%9F%E6%B0%A3%EF%BC%8C%E4%BD%A0%E5%8F%AF%E8%83%BD%E8%B8%A9%E5%88%B0%20SVN%20%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%AF%AB%E5%9C%B0%E9%9B%B7/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-09-23T02:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/content/images/tortoise-turned-upside.png" alt=""></p><h3 id="今天發生一則狀況">今天發生一則狀況</h3><p>我這邊 update SVN （Git 叫 pull）上的程式碼以後，遲遲編譯不過！</p><p>我就去責問同事 A 你怎麼又忘了把 instance 的宣告上傳？每一次 commit 要注意所有的 change 啊！同事 A 一臉為難又莫名其妙，我回座位去做其他事，等他更新 SVN 上的程式碼。</p><p>過了十幾分鐘，同事 B 又跑來問同事 A 程式碼更新了沒？同事 B 也遇到跟我一樣的狀況。急著要程式碼的同事 B，就叫同事 A 手動把內容傳給他了！</p><p>這就怪了，難道中間這十幾分鐘，同事 A 都在位置上玩手機？</p><hr><h3 id="追查案情">追查案情</h3><ol><li>首先直接看 SVN 上的程式碼，欸~怪了，明明是有更新的！</li><li>我這邊 local 端是否確實 update（Git 叫 pull）？有，reversion 號碼是一樣的。</li><li>往前追查 log，發現這個檔案有被改過檔名，xxx.designer.cs 改成了 xxx.Designer.cs，就改了一個字母 d 的大小寫。</li></ol><p>於是我懷疑，是不是大小寫差異，讓 SVN 看做是不同檔案而出了差錯？</p><hr><h3 id="半個水落石出">半個水落石出</h3><p>搜尋＂Tortoisesvn filename lower case＂，果然有一大堆人有跟我類似經驗。</p><p>Windows 檔名不區分大小寫，但是 SVN 區分大小寫。<br>所以在 Windows 底下，由小寫改過大寫以後，會造成錯亂。<br>我不知道這個錯亂的詳細過程是如何？目前還找不到，只知道會造成該檔案有人可以 commit 上去，別人也可以在 SVN server 上看最新程式碼，但是就沒辦法透過正常的 SVN update 把檔案拉下來。</p><hr><h3 id="避免方法">避免方法</h3><p>下次已經被 add 進 SVN 的檔案，如果要改檔名大小寫，記得要透過 SVN 本身的改名介面，不要直用 Windows 的方法改，不然就會跟我一樣踩到地雷，也委屈了倒楣的同事 A 喔！</p><hr><h3 id="附註">附註</h3><ul><li>基於某些原因，大家不得已在同一個 branch 上開發，所以很容易彼此干擾</li><li>基於某些原因，沒辦法把 SVN 換成 Git，所以很容易被這種事雷到</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/content/images/tortoise-turned-upside.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;今天發生一則狀況&quot;&gt;今天發生一則狀況&lt;/h3&gt;
&lt;p&gt;我這邊 update SVN （Git 叫 pull）上的程式碼以後，遲</summary>
      
    
    
    
    
    <category term="技術" scheme="https://mosdeo.github.io/tags/%E6%8A%80%E8%A1%93/"/>
    
    <category term="版本控制" scheme="https://mosdeo.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
</feed>
