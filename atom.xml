<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LKY 只有原創內容的 Blog</title>
  
  
  <link href="https://mosdeo.github.io/atom.xml" rel="self"/>
  
  <link href="https://mosdeo.github.io/"/>
  <updated>2021-07-25T13:57:52.232Z</updated>
  <id>https://mosdeo.github.io/</id>
  
  <author>
    <name>Lin, Kao-Yuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker部署測試用文章</title>
    <link href="https://mosdeo.github.io/2021/07/24/Docker%E9%83%A8%E7%BD%B2%E6%B8%AC%E8%A9%A6%E7%94%A8%E6%96%87%E7%AB%A0/"/>
    <id>https://mosdeo.github.io/2021/07/24/Docker%E9%83%A8%E7%BD%B2%E6%B8%AC%E8%A9%A6%E7%94%A8%E6%96%87%E7%AB%A0/</id>
    <published>2021-07-24T16:00:00.000Z</published>
    <updated>2021-07-25T13:57:52.232Z</updated>
    
    <content type="html"><![CDATA[<p>驗證是不是可以 Docker 部署？</p><p>成功的話，我就不用在新電腦上搞麻煩的 node 與 hexo 環境了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;驗證是不是可以 Docker 部署？&lt;/p&gt;
&lt;p&gt;成功的話，我就不用在新電腦上搞麻煩的 node 與 hexo 環境了。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="docker" scheme="https://mosdeo.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>近期機器學習工作踩到的5個坑</title>
    <link href="https://mosdeo.github.io/2021/05/18/%E8%BF%91%E6%9C%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%88%B0%E7%9A%845%E5%80%8B%E5%9D%91/"/>
    <id>https://mosdeo.github.io/2021/05/18/%E8%BF%91%E6%9C%9F%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E5%B7%A5%E4%BD%9C%E8%B8%A9%E5%88%B0%E7%9A%845%E5%80%8B%E5%9D%91/</id>
    <published>2021-05-18T16:00:00.000Z</published>
    <updated>2021-07-25T13:54:13.288Z</updated>
    
    <content type="html"><![CDATA[<p>最近主管突然想要大家識別某種生活物品，然後大家就卯起來幹了。</p><h2 id="第一坑：數據少">第一坑：數據少</h2><p>一開始的問題是樣本極少，第一天還不到10張，之後也可預見的不好蒐集，所以其他人一頭熱用 YOLO 之類的演算法同時，我評估深度學習不是好方法。越老舊的方法雖然上限越低，但可解釋性比較好，一般來說需要的數據量比較少。</p><p>都用一些比較傳統的方法，一開始先用 Cascade（就是 Viola–Jones 那個）</p><h2 id="第二坑：老演算法被新版棄用">第二坑：老演算法被新版棄用</h2><p>這裡就來了第一個大坑，OpenCV 4.X 已經拿掉了 Cascade 相關的東西，網路上一找可以看到很多人抱怨，當然抱怨大本營是 Github issue，官方建議大家改用 DNN，但還是很多人想要用復古的東西。</p><p>好吧，我只好降低版本到 3.X，這連帶讓我找適合的 docker image 基底都變得困難（因為編譯 OpenCV 太久，不能每次都編譯），還好最後還是找到了。</p><p>然後隨著樣本增加到幾百個，效果也不是很好。中間還做了哪些努力？因為我自己的 MacBook Air 很慢，所以花了很多時間寫 Dockerfile 還有一些部署相關的 bash，讓計算可以在公司的服務器上跑。但 docker build 與 debug 還是吃自己電腦上的算力，電腦不夠快的影響還是有。</p><p>後來覺得為了 debug 而 docker build 的次數太多了、太浪費時間，所以決定：</p><ul><li>Dockerfile 只做 apt install 或 pip install 之類的事，所有的程式碼、數據全都用 mount 的。</li><li>所有的流程都寫在 docker run 最後面的指令（/bin/bash -c “…”）</li><li>docker image、程式碼、數據集，各用一個 bash deploy 到 GPU server。</li></ul><h2 id="第三坑：用錯特徵">第三坑：用錯特徵</h2><p>後來我就發現，預設的特徵擷取法是 Haar，那個是針對人臉的明暗變化擷取特徵，不太適合現在的檢測目標。另外兩種可選特徵是 LBP 與 HoG，這兩種我都在寫論文或寫作業自乾過了，HoG 應該是最佳選擇。理論上，這只要改個參數就可以看到辨識率爆炸性的推進了吧？我以為看到了一條很棒的近路。</p><h2 id="第四坑：適合的特徵又被-Python-版棄用">第四坑：適合的特徵又被 Python 版棄用</h2><p>結果發現 OpenCV 3.X 可以訓練基於 HoG 的 Cascade 模型，但是卻不能 load 基於 HoG 的 XML model？必須要 2.X 才能，那我就再度降低版本到 2.X 吧！這次更慘，發現沒得降低了，因為 Python 的 OpenCV 最低就是從 3.X 開始，如果降低到 OpenCV 2.X 那從 load XML model 以後的所有事情我都要用 CPP 寫，太累了！</p><p>https://github.com/shimat/opencvsharp/issues/1022</p><p>搜一下發現很多人用 HoG + SVM 的組合做目標檢測，尤其行人與車輛，感覺還蠻適合現在的目標。發現用的函式庫有兩大派別，老的 OpenCV 與新的 scikit-image。</p><h2 id="第五坑：造好的輪子還是要自己補胎">第五坑：造好的輪子還是要自己補胎</h2><p>然後就找一下 Github 現成的輪子，發現有一個看起來寫得不錯、夠規整、文件夠清楚，有把一些設定獨立在 config.cfg。clone 下來之後發現是除了 Python2 之外，還有一些錯字、一些API過時了，改了將近一天才跑起來。</p><p>跑起來之後有坑啊，一直跑出「array has an inhomogeneous shape after 1 dimensions.」，原來是我的訓練圖片大小都不一樣，沒有經過正規化。給模型的所有數據維度都要一樣大，這其實應該是個機器學習常識才對，甚至也是統計常識，只是現成的工具太方便了，習慣都被養壞了。</p><p>接下又要繼續解這個不是坑的坑…（待續）</p><p>（還有一些數據視覺化的坑沒寫，不過我懶了，下次再寫）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近主管突然想要大家識別某種生活物品，然後大家就卯起來幹了。&lt;/p&gt;
&lt;h2 id=&quot;第一坑：數據少&quot;&gt;第一坑：數據少&lt;/h2&gt;
&lt;p&gt;一開始的問題是樣本極少，第一天還不到10張，之後也可預見的不好蒐集，所以其他人一頭熱用 YOLO 之類的演算法同時，我評估深度學習不是好方</summary>
      
    
    
    
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="機器學習" scheme="https://mosdeo.github.io/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
    <category term="AI" scheme="https://mosdeo.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>如何用Docker高效部署Python寫的機器學習推論服務</title>
    <link href="https://mosdeo.github.io/2021/05/01/%E5%A6%82%E4%BD%95%E7%94%A8Docker%E9%AB%98%E6%95%88%E9%83%A8%E7%BD%B2Python%E5%AF%AB%E7%9A%84%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E6%8E%A8%E8%AB%96%E6%9C%8D%E5%8B%99/"/>
    <id>https://mosdeo.github.io/2021/05/01/%E5%A6%82%E4%BD%95%E7%94%A8Docker%E9%AB%98%E6%95%88%E9%83%A8%E7%BD%B2Python%E5%AF%AB%E7%9A%84%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E6%8E%A8%E8%AB%96%E6%9C%8D%E5%8B%99/</id>
    <published>2021-05-01T16:00:00.000Z</published>
    <updated>2021-05-02T01:50:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>這一篇是我個人近期的經驗總結。個人感覺與 Docker 相見恨晚，要是早點懂，以前做的機器學工具，效果都能放大很多倍了。</p><p>以前總覺得把程式碼放到別的 server、別的電腦上跑，要搞定各種環境細節上的差異，是一件骯髒的苦差事。自從有了 Docker，一切都變得輕鬆快速無負擔。</p><p><img src="/content/images/DockerDeploy.png" alt=""></p><p>每次一鍵部署（如上圖）都覺得很爽快！從改完程式碼到上線生效，就只有一行指令的距離（前提是網路穩定、指令編寫正確）。</p><h2 id="準備">準備</h2><ul><li>必須：<ul><li>開發機＆目標機，都要安裝 Docker</li><li>至少需要寫一個簡單 server（建議 Python+Flask），方便推論數據進出虛擬機</li></ul></li><li>建議：盡可能不要把只有訓練才用到的東西（程式碼、數據、函式庫）部署出去，所以能做以下這些事：<ul><li>「訓練＆推論」數據分離<ul><li>不必分開放。兩種數據不在同一個文件內，路徑能區分清楚就好。</li></ul></li><li>「訓練＆推論」城市碼分離<ul><li>前提：模型能存檔，可用 pickle r/w。</li></ul></li><li>pip install 加速與減負<ul><li>–no-cache-dir 映像是免洗筷環境，不快取，爭取輕量</li><li>中國大陸內 proxy<ul><li>pip3 install XXX -i https://mirrors.ustc.edu.cn/pypi/web/simple/</li></ul></li><li>requirements.txt 定向瘦身<ul><li>pip3 install pipreqs</li><li>pipreqs .（在要部署的repo內）</li><li>效果？<ul><li>1.54GB VS 424MB</li><li>大的已經手動刪除很多 package，還是這麼大。手動刪除效果比不上自動工具。</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="觀念">觀念</h2><ol><li>Docker 虛擬機是一個小黑屋</li><li>人可以用，但不能親自操作</li><li>一切操作都要寫在一張紙上，請 Docker 管家代辦</li><li>這張紙叫做 Dockerfile （第一個字母必須大寫）</li></ol><ul><li>Dockerfile 上的交辦事項分兩大類：<ul><li>如何裝修？（一次性設置）</li><li>以後每次進門的慣例？（重複使用）</li></ul></li><li>Dockerfile 的好處＆不足：<ul><li>強迫開發者把環境設定寫成程式碼，可標準化、可輕易重復。</li><li>對機器學習來說，Dockerfile 只能標準化推論與部署。訓練與演算法的內涵 Docker 管不到，還是要主動寫才會留下。（這句看起來很像「一分鐘有60秒」之類的廢話，但很真的很多主管不懂機器學習）</li></ul></li><li>Dockerfile 將會與 Python 程式碼一起維護，是整個 repo 程式碼的一部分。</li><li>Dockerfile 的寫法，就是打包服務的重點。</li></ul><h2 id="操作">操作</h2><ul><li>撰寫 Dockerfile</li><li>docker build（裝修）</li><li>docker run（執行慣例）</li><li>上述操作失敗的應對方式：說清楚太麻煩，我靠大量練習與肌肉記憶</li></ul><h2 id="延伸">延伸</h2><ul><li>Python官方鏡像各版本差異<ul><li>https://hub.docker.com/_/python Image_Variants</li></ul></li><li>製作運行 Python 的 docker image 前，如何選擇 docker 基底鏡像？<ul><li>https://aws.amazon.com/cn/blogs/china/choose-the-best-docker-image-for-your-python-application/</li></ul></li><li>bash 一鍵部署<ul><li>如何撰寫 bash</li><li>Linux 子帳號權限設置</li><li>put ssh pub key to the server</li></ul></li><li>log 或其他 container 產生數據<ul><li>container 如免洗餐具，隨時消失、隨時可棄，不應該留存數據。</li><li>數據保存應該用 mount 或 volume。</li></ul></li></ul><h2 id="待解決問題：">待解決問題：</h2><ul><li>Python 演算法或模型，是否應該用 mount 做到彈性更新？</li><li>多個虛擬機連動：docker compose</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這一篇是我個人近期的經驗總結。個人感覺與 Docker 相見恨晚，要是早點懂，以前做的機器學工具，效果都能放大很多倍了。&lt;/p&gt;
&lt;p&gt;以前總覺得把程式碼放到別的 server、別的電腦上跑，要搞定各種環境細節上的差異，是一件骯髒的苦差事。自從有了 Docker，一切都變得</summary>
      
    
    
    
    
    <category term="機器學習" scheme="https://mosdeo.github.io/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
    <category term="後端" scheme="https://mosdeo.github.io/tags/%E5%BE%8C%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>為什麼物聯網落地困難、賣點稀少、有價值數據獲取困難，大多只能作為噱頭？談我的經驗</title>
    <link href="https://mosdeo.github.io/2020/12/09/%E7%82%BA%E4%BB%80%E9%BA%BC%E7%89%A9%E8%81%AF%E7%B6%B2%E8%90%BD%E5%9C%B0%E5%9B%B0%E9%9B%A3%E3%80%81%E8%B3%A3%E9%BB%9E%E7%A8%80%E5%B0%91%E3%80%81%E6%9C%89%E5%83%B9%E5%80%BC%E6%95%B8%E6%93%9A%E7%8D%B2%E5%8F%96%E5%9B%B0%E9%9B%A3%EF%BC%8C%E5%A4%A7%E5%A4%9A%E5%8F%AA%E8%83%BD%E4%BD%9C%E7%82%BA%E5%99%B1%E9%A0%AD%EF%BC%9F%E8%AB%87%E6%88%91%E7%9A%84%E7%B6%93%E9%A9%97/"/>
    <id>https://mosdeo.github.io/2020/12/09/%E7%82%BA%E4%BB%80%E9%BA%BC%E7%89%A9%E8%81%AF%E7%B6%B2%E8%90%BD%E5%9C%B0%E5%9B%B0%E9%9B%A3%E3%80%81%E8%B3%A3%E9%BB%9E%E7%A8%80%E5%B0%91%E3%80%81%E6%9C%89%E5%83%B9%E5%80%BC%E6%95%B8%E6%93%9A%E7%8D%B2%E5%8F%96%E5%9B%B0%E9%9B%A3%EF%BC%8C%E5%A4%A7%E5%A4%9A%E5%8F%AA%E8%83%BD%E4%BD%9C%E7%82%BA%E5%99%B1%E9%A0%AD%EF%BC%9F%E8%AB%87%E6%88%91%E7%9A%84%E7%B6%93%E9%A9%97/</id>
    <published>2020-12-09T16:00:00.000Z</published>
    <updated>2021-02-02T06:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="裝置電力短缺">裝置電力短缺</h2><p>物聯網裝置通常都是吃電池，很少有插電的機會。新硬件設計的時候，最大瓶頸是裝置的電力有限，但各部門都想在裝置上加入對自己有利的耗電項目。</p><p>行銷部門想放廣告、GIS 部門想裝 GPS、維運部門想寫入更多的 log、跟醫院合作的部門想裝運動感測器等等，這些需求都在爭搶極其有限的電力。給這些裝置充電，比給自己的手機半天一充還要困難。</p><p>為了裝更多的感測器，我連「用 DMA 節省 CPU 耗電」、「常態休眠，等感測器發出中斷再喚醒」這些很韌體技巧都提出來了，我還自己去查感測器的 datasheet 想辦法找出耗電量比較少的型號。</p><h2 id="數據孤島">數據孤島</h2><p>這個問題已經在網上被介紹過很多次，就不詳述。數據孤島有企業與企業之間的、也有部門與部門之間的，沒有統一的標準、沒有流通的數據，也會降低的數據的價值。一但被認定數據的價值不夠，在上一點「裝置電力短缺」就會被否決安裝感測器的需求。</p><p>通常數據價值已經被管理層看到的時候，都是別家企業已經拿數據做出應用、講出故事的時候，這時候想在營運中的系統加上感測器已經來不及，就算裝了，應用場域的機會與話語權，也早已經被先行的企業拿下。</p><style>    .center {    display: block;    margin-left: auto;    margin-right: auto;    width: 50%;    }</style><p>    <img src="/content/images/YouBike_1VS2.webp" class="center"></p><p>上圖是我參與過初期規劃階段的產品，我離職時：</p><ul><li><p>參考了很多中國大陸共享單車的方案，呼聲最高是類似現在中國大陸實行的虛擬停車柱/停車區，最後不知道為什麼沒採用，但不論開發商或當局政府都採取很保守的態度，很多先進的提案都沒實施，估計是被「單車墳場」的文章嚇到了。</p></li><li><p>當時落地營運的還只有 1.0，1.0 上沒有任何感測器或長距離通訊裝置，只有一組向停車柱回報車 ID，類似 NFC 的線圈。</p></li><li><p>2.0 版連塗裝都是我離職多年後才在路上看到，也不知道當年提案的感測器到底裝了哪些…</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;裝置電力短缺&quot;&gt;裝置電力短缺&lt;/h2&gt;
&lt;p&gt;物聯網裝置通常都是吃電池，很少有插電的機會。新硬件設計的時候，最大瓶頸是裝置的電力有限，但各部門都想在裝置上加入對自己有利的耗電項目。&lt;/p&gt;
&lt;p&gt;行銷部門想放廣告、GIS 部門想裝 GPS、維運部門想寫入更多的 l</summary>
      
    
    
    
    
    <category term="運動" scheme="https://mosdeo.github.io/tags/%E9%81%8B%E5%8B%95/"/>
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
    <category term="靠盃" scheme="https://mosdeo.github.io/tags/%E9%9D%A0%E7%9B%83/"/>
    
    <category term="批判" scheme="https://mosdeo.github.io/tags/%E6%89%B9%E5%88%A4/"/>
    
    <category term="技術" scheme="https://mosdeo.github.io/tags/%E6%8A%80%E8%A1%93/"/>
    
    <category term="YouBike" scheme="https://mosdeo.github.io/tags/YouBike/"/>
    
    <category term="公共運輸" scheme="https://mosdeo.github.io/tags/%E5%85%AC%E5%85%B1%E9%81%8B%E8%BC%B8/"/>
    
    <category term="單車" scheme="https://mosdeo.github.io/tags/%E5%96%AE%E8%BB%8A/"/>
    
    <category term="韌體" scheme="https://mosdeo.github.io/tags/%E9%9F%8C%E9%AB%94/"/>
    
  </entry>
  
  <entry>
    <title>我在微信公眾號上的文章清單(滾動更新)</title>
    <link href="https://mosdeo.github.io/2020/09/12/%E6%88%91%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E7%9C%BE%E8%99%9F%E4%B8%8A%E7%9A%84%E6%96%87%E7%AB%A0%E6%B8%85%E5%96%AE_%E6%BB%BE%E5%8B%95%E6%9B%B4%E6%96%B0/"/>
    <id>https://mosdeo.github.io/2020/09/12/%E6%88%91%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%85%AC%E7%9C%BE%E8%99%9F%E4%B8%8A%E7%9A%84%E6%96%87%E7%AB%A0%E6%B8%85%E5%96%AE_%E6%BB%BE%E5%8B%95%E6%9B%B4%E6%96%B0/</id>
    <published>2020-09-12T16:00:00.000Z</published>
    <updated>2020-12-10T08:31:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>由於在微信的資料池裡面，搜尋我自己的名字，會被某個同名同姓的乒乓球選手新聞淹沒，所以我特地把自己發表在微信公眾號上的文章做一個清單，方便我自己查閱。</p><h3 id="技術">技術</h3><h4 id="Go语言中文网">Go语言中文网</h4><p>2020-09-13 <a href="https://mp.weixin.qq.com/s/pP3hJKa-EGvLXi0luL1cRg">面试官：这个经典的并发问题用 Go 语言如何实现？</a></p><p>2020-04-03 <a href="https://mp.weixin.qq.com/s/K032xlARjiyS8ecJrqZXaA">LeetCode Go 并发题详解：交替打印字符串</a></p><p>2020-02-19 <a href="https://mp.weixin.qq.com/s/zMZXd8DLtjhm06Q0lm1pcg">只在我计算机上能跑的代码：select-case-default 忘记让出 CPU 的坑</a></p><p>2020-02-16 <a href="https://mp.weixin.qq.com/s/WJJL-3pkeA8qBF75QTt9Ag">面试题实战：给一个数 n，使用 Go 打印交替顺序零与奇偶数</a></p><p>2020-02-11 <a href="https://mp.weixin.qq.com/s/wL-Cy6DScmPIpQAma6_3Qw">多 Goroutine 的并发程序如何保证按序输出？channel 的使用是关键</a></p><p>2020-02-04 <a href="https://mp.weixin.qq.com/s/I5va3PI1oGIj8R_n3Nw2yw">LeetCode上并发题目无Go版本：台湾同胞试水 — 交替打印FooBar</a></p><h3 id="非技術">非技術</h3><p>2020-02-14 <a href="https://mp.weixin.qq.com/s/9KEpxb6h6aGJvMnQXUS_Hg">在台湾亲身经历约口罩抢购热潮…</a></p><p>2020-02-11 <a href="https://mp.weixin.qq.com/s/iBBroMhDxz1VYJiI62QYMw">我在台湾亲历口罩抢购潮 | 人在书店×2002</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由於在微信的資料池裡面，搜尋我自己的名字，會被某個同名同姓的乒乓球選手新聞淹沒，所以我特地把自己發表在微信公眾號上的文章做一個清單，方便我自己查閱。&lt;/p&gt;
&lt;h3 id=&quot;技術&quot;&gt;技術&lt;/h3&gt;
&lt;h4 id=&quot;Go语言中文网&quot;&gt;Go语言中文网&lt;/h4&gt;
&lt;p&gt;2020-</summary>
      
    
    
    
    
    <category term="大陸" scheme="https://mosdeo.github.io/tags/%E5%A4%A7%E9%99%B8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：經典哲學家吃飯問題：碰運氣解法</title>
    <link href="https://mosdeo.github.io/2020/09/01/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_%E7%B6%93%E5%85%B8%E5%93%B2%E5%AD%B8%E5%AE%B6%E5%90%83%E9%A3%AF%E5%95%8F%E9%A1%8C_%E7%A2%B0%E9%81%8B%E6%B0%A3%E8%A7%A3%E6%B3%95/"/>
    <id>https://mosdeo.github.io/2020/09/01/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_%E7%B6%93%E5%85%B8%E5%93%B2%E5%AD%B8%E5%AE%B6%E5%90%83%E9%A3%AF%E5%95%8F%E9%A1%8C_%E7%A2%B0%E9%81%8B%E6%B0%A3%E8%A7%A3%E6%B3%95/</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2020-09-02T13:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/the-dining-philosophers/">https://leetcode.com/problems/the-dining-philosophers/</a></p><h2 id="本題題目">本題題目</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/400px-An_illustration_of_the_dining_philosophers_problem.png" alt=""></p><p>「哲學家吃飯問題」是一個作業系統中的經典問題，所以抽象題幹我就不再贅述，直接說實作要求。</p><blockquote><p>The philosophers’ ids are numbered from 0 to 4 in a clockwise order. Implement the function void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) where:</p></blockquote><p>有幾位哲學家，他們的 ID 順時針由 0~4，實作一個函數 <code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code>，其中…</p><blockquote><p>philosopher is the id of the philosopher who wants to eat.</p></blockquote><p>參數 <code>philosopher</code> 代表想要吃飯的哲學家的 ID。</p><blockquote><p>pickLeftFork and pickRightFork are functions you can call to pick the corresponding forks of that philosopher.</p></blockquote><p>參數 <code>pickLeftFork</code> and <code>pickRightFork</code> 是函數，你必須呼叫他們來使哲學家拿起對應的叉子。</p><blockquote><p>eat is a function you can call to let the philosopher eat once he has picked both forks.</p></blockquote><p>當哲學家拿起兩隻叉子後，你必須呼叫 <code>eat</code> 這個函數讓哲學家吃一次。</p><blockquote><p>putLeftFork and pickRightFork are functions you can call to put down the corresponding forks of that philosopher.</p></blockquote><p>參數 <code>putLeftFork</code> and <code>pickRightFork</code> 是函式，你必須呼叫他們來使哲學家放下手中的叉子。</p><blockquote><p>The philosophers are assumed to be thinking as long as they are not asking to eat (the function is not being called with their number).</p></blockquote><p>假設哲學家們都會思考很久，中間都不會要求吃東西（呼叫函式 thinking() 不必使用哲學家們的 ID）</p><blockquote><p>Five threads, each representing a philosopher, will simultaneously use one object of your class to simulate the process. It is possible that the function will be called for the same philosopher more than once, even before the last call ends.</p></blockquote><p>五個執行緒，每一個執行緒代表都一個哲學家，用一個類(在 Go 語言是 struct)模擬這個 process。這個函式可能被同一個哲學家呼叫多次，甚至在最後一次呼叫結束前的途中都有可能。</p><h2 id="「叉子」與「筷子」">「叉子」與「筷子」</h2><p>最早課本裡都是說「叉子」。但我大學上 OS 的時候老師就提過一個疑問：「用叉子吃義大利麵，一隻就夠了，沒必要用到兩隻吧？所以，改成用筷子是不是更合理一點？但沒辦法，誰叫這門學問是西方先發明的？我們就當作筷子吧」。<br>於是，本文也決定照改，以下都用「筷子」代替「叉子」。</p><h2 id="本題考核難點？「拿得起放不下」造成死結、「無限輪迴」造成活結飢餓至死">本題考核難點？「拿得起放不下」造成死結、「無限輪迴」造成活結飢餓至死</h2><p>在過去的 LeetCode Concurrency 詳解中，我提到過很多次：</p><blockquote><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 順序控制的能力。</p></blockquote><p>但前面幾題的解法，大多是把判斷責任中心化，方便控管順序。這次，與前面幾題不同的是，這一題要求把判斷責任分散到每一位哲學家 thread 身上，哲學家彼此之間並不溝通，因此很容易發生資源互卡，也就是 deadlock。本文所示範的 channel 使用方法已經完全避免了死結(deadlock)。但這樣就沒問題了嗎？不，還有可能發生<a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81#%E6%B4%BB%E7%B5%90">活結(livelock)</a>。</p><p>這邊我為了示範 goroutine，先用最笨的碰運氣解法，也就是不刻意做任何資源配置，要在運氣很壞的情況下才會遇上 livelock。什麼是「運氣很壞的情況」？就是所有哲學家剛好在同一時間拿起同一邊的叉子。但實作上，由於我給每位哲學家一個隨機的思考時間 50mS（如下列程式碼），碰撞的機會是(1/50)^5，所以絕大部分情況下不會發生 livelock。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Think</span><span class="params">()</span></span> &#123;</span><br><span class="line">Random := <span class="function"><span class="keyword">func</span><span class="params">(max <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line"><span class="keyword">return</span> rand.Int() % (max + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-time.After(time.Millisecond * time.Duration(Random(<span class="number">50</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wiki 上有介紹不需要碰運氣，保證不會讓 thread 飢餓致死的演算法，但我自己也沒搞懂，請容我日後再介紹。</p><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><p>本題採用 5 個 buffered channel，分別代表 5 支筷子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DiningPhilosophers <span class="keyword">struct</span> &#123;</span><br><span class="line">wg                     *sync.WaitGroup</span><br><span class="line">streamForks            [<span class="number">5</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">missingDoubleForkTimes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Channel 初始化</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> diningPhilosophers.streamForks &#123;</span><br><span class="line">diningPhilosophers.streamForks[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叫所有哲學家開始動作</span></span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> diningPhilosophers.streamForks &#123;</span><br><span class="line">diningPhilosophers.wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> diningPhilosophers.WantToEat(i, PickLeftFork, PickRightFork, Eat, PutLeftFork, PutRightFork)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊開始計時後，是一個 foreach。<br>老方法，用 <code>sync.WaitGroup</code> 同步 5 個哲學家 goroutine 結束時間。<br>給每一位哲學家起一個「WantToEat」的 goroutine，告訴他 i 你是幾號？又給入「PickLeftFork, PickRightFork, Eat, PutLeftFork, PutRightFork」五個函式的的 function reference。</p><h3 id="2-五個-goroutine-之間，如何交接棒？">2. 五個 goroutine 之間，如何交接棒？</h3><p>沒有交接棒問題，每位哲學家就憑運氣去搶左右邊的兩隻筷子。<br>要注意的只有三件事情：</p><ol><li>無法同時搶到兩隻筷子的哲學家，必須先放棄到手的一支筷子。</li><li>已經同時搶到兩隻筷子的哲學家，吃完就必須退出餐桌。</li><li>還沒吃到的哲學家，可以無限次搶。</li></ol><h4 id="自循環-外部啟動注意事項">自循環 &amp; 外部啟動注意事項</h4><p>這次解題沒有實作這些協調機制，5 個 goroutine 只靠前述的三條規範野蠻生長。</p><h4 id="實作前述的三條規範的-WantToEat">實作前述的三條規範的 WantToEat()</h4><ul><li>本質上就是代表「還沒吃到的哲學家，可以無限次搶」的無限迴圈。</li><li>「已經同時搶到兩隻筷子的哲學家，吃完就必須退出餐桌」是此迴圈的結束條件。</li><li>「無法同時搶到兩隻筷子的哲學家，必須先放棄到手的一支筷子。」是此迴圈其中一個分支。</li></ul><p>有一行「<code>return //吃飽離開</code>」，整個流程最終目的就是要走到這一行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DiningPhilosophers)</span> <span class="title">WantToEat</span><span class="params">(philosopher <span class="keyword">int</span>, pickLeftFork <span class="keyword">func</span>(<span class="keyword">int</span>)</span>, <span class="title">pickRightFork</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>, <span class="title">eat</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>, <span class="title">putLeftFork</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>, <span class="title">putRightFork</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> this.wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> leftNum = (philosopher + <span class="number">4</span>) % <span class="number">5</span>  <span class="comment">//取得該哲學家左邊的號碼</span></span><br><span class="line"><span class="keyword">var</span> rightNum = (philosopher + <span class="number">6</span>) % <span class="number">5</span> <span class="comment">//取得該哲學家右邊的號碼</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> this.streamForks[leftNum] &lt;- philosopher: <span class="comment">//嘗試拿起左邊筷子</span></span><br><span class="line">PickLeftFork(philosopher) <span class="comment">//成功拿起左邊筷子</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> this.streamForks[rightNum] &lt;- philosopher: <span class="comment">//嘗試拿起右邊筷子</span></span><br><span class="line">PickRightFork(philosopher)  <span class="comment">//成功拿起又邊筷子</span></span><br><span class="line">Eat(philosopher)            <span class="comment">//左右邊都拿到了，開始吃</span></span><br><span class="line">&lt;-this.streamForks[leftNum] <span class="comment">//吃完了，放下左邊筷子</span></span><br><span class="line">PutLeftFork(philosopher)</span><br><span class="line">&lt;-this.streamForks[rightNum] <span class="comment">//吃完了，放下右邊筷子</span></span><br><span class="line">PutRightFork(philosopher)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//吃飽離開</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//無法拿起右邊筷子</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Philosopher %d can&#x27;t pick fork %d.\n&quot;</span>, philosopher, rightNum)</span><br><span class="line">&lt;-this.streamForks[leftNum] <span class="comment">//把已經拿起來的左邊筷子釋放出去</span></span><br><span class="line">PutLeftFork(philosopher)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//無法拿起左邊筷子</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Philosopher %d can&#x27;t pick fork %d.\n&quot;</span>, philosopher, leftNum)</span><br><span class="line">&#125;</span><br><span class="line">this.missingDoubleForkTimes++</span><br><span class="line">Think()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊對於每一隻筷子的具體表現就是一個 buffered channel，迴圈流程如下：</p><ol><li><p>先嘗試把自己的號碼塞入左邊的 buffered channel</p><ul><li>成功了，就是搶到一隻筷子，往下。</li><li>失敗了，跳到「<code>default: //無法拿起左邊筷子</code>」，思考一下，然後從頭開始。</li></ul></li><li><p>再嘗試把自己的號碼塞入右邊的 buffered channel</p><ul><li>成功了，就是搶到兩隻筷子，開始吃，吃飽離開，退出餐桌。</li><li>失敗了，跳到「<code>default: //無法拿起右邊筷子</code>」，把已經搶到的左邊筷子還回去，思考一下，然後從頭開始。</li></ul></li></ol><p>在 console 輸出，可以看到代表每一位哲學家的 goroutine 詳細動作過程，錯過筷子次數並不多，大部分執行結果的錯過次數在 3~5 次（點擊以下的「完整解題程式碼」就能體驗）。</p><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p><a href="https://play.golang.org/p/neTH25E8ayX">https://play.golang.org/p/neTH25E8ayX</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/DiningPhilosophersProblem%E7%A4%BA%E6%84%8F%E5%9C%9620200902.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。&lt;/p&gt;
&lt;h2 id=&quot;本題-LeetCode-連結：&quot;&gt;本題 Leet</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>眾說紛紜的生長激素調控因子整理</title>
    <link href="https://mosdeo.github.io/2020/06/29/%E7%9C%BE%E8%AA%AA%E7%B4%9B%E7%B4%9C%E7%9A%84%E7%94%9F%E9%95%B7%E6%BF%80%E7%B4%A0%E8%AA%BF%E6%8E%A7%E5%9B%A0%E5%AD%90/"/>
    <id>https://mosdeo.github.io/2020/06/29/%E7%9C%BE%E8%AA%AA%E7%B4%9B%E7%B4%9C%E7%9A%84%E7%94%9F%E9%95%B7%E6%BF%80%E7%B4%A0%E8%AA%BF%E6%8E%A7%E5%9B%A0%E5%AD%90/</id>
    <published>2020-06-29T16:00:00.000Z</published>
    <updated>2020-07-08T06:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>生長激素（Growth Hormone；GH）對於想要健身長肌肉的人來說，是特別重要的一項荷爾蒙，因為他能促進肌肉生長、又加速消耗脂肪，對於想要明顯線條好身材的人來說是好朋友。</p><p>所以，我們得知道怎樣可以讓生長激素更多？又怎樣避免生長激素減少？這是很多營養健身 YouTuber 會介紹的主題，但是營養健身 YouTuber 偶爾講到有些地方會與課本衝突，所以這邊地特整理:</p><ol><li>我在教科書上找到的生長激素調控因子，讓我們有來源更明確、更權威的根據，掌握自己的生長激素。</li><li>YouTuber 講得比較有疑問之處，留待日後釐清。</li></ol><h2 id="解剖生理學，許世昌著，民國98年永大出版">解剖生理學，許世昌著，民國98年永大出版</h2><p>比較特別的是，這邊寫到胺基酸的增減會影響到生長激素，這是我在其他地方都沒看到的調控因子。</p><p><img src="/content/images/GrowthHormone/IMG_1136.jpg" alt=""></p><h2 id="運動生理學，林正常校閱，2002年麥格羅希爾出版（黑人跑步封面）">運動生理學，林正常校閱，2002年麥格羅希爾出版（黑人跑步封面）</h2><p>這張圖用很清楚的方塊來表示各個因子之間的調控關係，</p><ul><li>生長激素並不是直接增肌，而是傳遞給肝臟，肝臟才以促生長激素(類胰島素生長因子)增肌。</li><li>生長激素的效果會對自身產生負回授。</li></ul><p><img src="/content/images/GrowthHormone/IMG_1137.jpg" alt=""></p><p>然而，書中講到生長激素作用時，強調「靜效果是保持血漿葡萄糖濃度」。若以這點來看，眾多的生長激素調控因子中，可能只有「低血糖」這一項是鐵律，其他或許只是相關，而非因果？</p><p><img src="/content/images/GrowthHormone/IMG_1138.jpg" alt=""></p><p>書中又給了更清楚的量化關係，顯示血中的生長激素與 VO2Max% 有極為強烈的關係！也難怪有些說法是「高強度間歇訓練可促進生長激素」。</p><p><img src="/content/images/GrowthHormone/IMG_1139.jpg" alt=""></p><h2 id="肌力與體能訓練，林貴福等譯，2017禾楓出版（俗稱「藍聖經」）">肌力與體能訓練，林貴福等譯，2017禾楓出版（俗稱「藍聖經」）</h2><p>這本書花了不少篇幅談生長激素，但沒有像其他幾本書說的那麼簡單，關注在相當多模凌兩可或很複雜的點上，例如：</p><ul><li>低強度高反覆的阻力運動(28% 7RM)，不會提高生長激素濃度</li><li>女性對生長激素濃度的反應</li><li>訓練的適應</li><li>IGFs</li></ul><p><img src="/content/images/GrowthHormone/IMG_1170.jpg" alt=""></p><p>真要說這本書讓我認識了什麼新的調控因子？大概就是重訓前後吃些蛋白質醣類吧（如下圖）</p><p><img src="/content/images/GrowthHormone/IMG_1171.jpg" alt=""></p><h2 id="比較【力竭與不力竭】在重訓時的優劣勢｜健人訓練｜2017ep13">比較【力竭與不力竭】在重訓時的優劣勢｜健人訓練｜2017ep13</h2><p><img src="/content/images/GrowthHormone/BFYEnLgWN18.png" alt=""></p><p><a href="https://youtu.be/BFYEnLgWN18?t=314">05:14</a> 所說「氫離子、乳酸可以促進生長激素」，但我目前沒在任何文獻上看到這兩樣物質有被列為生長激素調控因子。</p><p>若更積極一點，進一步去跟生長激素扯上關係？我能想到的是，乳酸會被作為糖質新生的原料用，所以會間接提高血糖，故乳酸會抑制生長激素才對吧？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;生長激素（Growth Hormone；GH）對於想要健身長肌肉的人來說，是特別重要的一項荷爾蒙，因為他能促進肌肉生長、又加速消耗脂肪，對於想要明顯線條好身材的人來說是好朋友。&lt;/p&gt;
&lt;p&gt;所以，我們得知道怎樣可以讓生長激素更多？又怎樣避免生長激素減少？這是很多營養健身 </summary>
      
    
    
    
    
    <category term="運動科學" scheme="https://mosdeo.github.io/tags/%E9%81%8B%E5%8B%95%E7%A7%91%E5%AD%B8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：Fizz Buzz Multithreaded</title>
    <link href="https://mosdeo.github.io/2020/02/22/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_FizzBuzzMultithreaded/"/>
    <id>https://mosdeo.github.io/2020/02/22/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_FizzBuzzMultithreaded/</id>
    <published>2020-02-22T16:00:00.000Z</published>
    <updated>2021-05-02T01:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次將會示範 goroutine 教學中常講到的「不要透過共享來通訊，而要透過通訊來共享」。</p><p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/fizz-buzz-multithreaded/">https://leetcode.com/problems/fizz-buzz-multithreaded/</a></p><h2 id="本題題目">本題題目</h2><p>給定一個數列從 1 ~ n，依序輸出，但是:</p><ul><li>如果 n 可以被 3 整除，輸出 “fizz”</li><li>如果 n 可以被 5 整除，輸出 “buzz”</li><li>如果 n 同時可以被 3 與 5 整除，輸出 “fizzbuzz”</li></ul><p>實作要求：使用 4 個執行緒實現一個多執行緒版本。一個 FizzBuzz 的 instance 要被傳遞到以下四個執行緒中:</p><ul><li>Thread A 會呼叫 <code>fizz()</code>     以檢查 n 是否可以被    3 整除？若可以就輸出 fizz</li><li>Thread B 會呼叫 <code>buzz()</code>     以檢查 n 是否可以被    5 整除？若可以就輸出 buzz</li><li>Thread C 會呼叫 <code>fizzbuzz()</code> 以檢查 n 是否可以被 3, 5 整除？若可以就輸出 fizzbuzz</li><li>Thread D 會呼叫 <code>number()</code>   照常輸出原本數字 n</li></ul><h2 id="本題考核難點？判斷責任去中心化！">本題考核難點？判斷責任去中心化！</h2><p>我一開始認為「這題沒什麼難的嘛～還不就那些套路再用一次！」，所以<a href="https://play.golang.org/p/QkeogzEtS5R">最早的實作版本</a>，是寫了一個中心控管的 goroutine，判斷整除條件後，再把輸出任務透過 channel 發派給其他 goroutine A, B, C, D。</p><p>直到我為了分享這題，將英文題目翻譯為中文的時候，才發現自己誤解題目了(尷尬)！題目真正的要求更困難，要各個 goroutine 自行負擔檢查整除條件的責任。所以只好重寫 XD</p><p>在過去的 LeetCode Concurrency 詳解中，我提到過很多次：</p><blockquote><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 順序控制的能力。</p></blockquote><p>但前面幾題的解法，大多是把判斷責任中心化，方便控管順序。這次，與前面幾題不同的是，這一題要求把判斷責任分散到 thread A, B, C 中，所以每個 goroutine 也無法準確得知下一個要接棒的 goroutine 是哪一個？這樣的順序控制會由於分散化，變得更加困難。</p><blockquote><p>By the way，我還解過「DiningPhilosophers」這一題用的就是去中心化方法，但目前還沒寫那一題詳解。</p></blockquote><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FizzBuzz <span class="keyword">struct</span> &#123;</span><br><span class="line">n           <span class="keyword">int</span></span><br><span class="line">wg          *sync.WaitGroup</span><br><span class="line">streamBaton <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fizzbuzz := &amp;FizzBuzz&#123;</span><br><span class="line">n:           testCase,</span><br><span class="line">wg:          &amp;sync.WaitGroup&#123;&#125;,</span><br><span class="line">streamBaton: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依照題目採用一個 FizzBuzz 物件 pass 到各個 goroutine 之中，當中有 buffered channel <code>streamBaton</code> 長度為一，可儲存一個整數。</p><h3 id="2-四個-goroutine-之間，如何交接棒？">2. 四個 goroutine 之間，如何交接棒？</h3><p>這一題在 goroutine 之間交接棒的規則更複雜，所以我決定不像之前一樣指定的交接棒，而是每一個 goroutine 都把訊息丟到同一個 channel 裡面去，大家都去「各取所需」，看看是不是符合自己的整除規則？如果不是，表示自己還沒接到棒，要把數字再寫回 channel 讓應該接這一棒的 goroutine 可以讀取到資訊。</p><p>這樣有壞處，那就是會多很多次沒有命中的 channel 讀取，若不是自己要的還得把數值還回去。做個比喻，就像老闆雇用員工吧，因為不具備識人能力，都先雇用再說，不對再趕走。（只是比喻，如有雷同，純屬巧合）</p><p>受限於 channel 的性質，看了就會改變內容，所以若沒有命中就多了「還回去」的動作，無法如同 get 存取子一樣只讀不寫。</p><h4 id="自循環-外部啟動注意事項">自循環 &amp; 外部啟動注意事項</h4><p>首先，這個循環是從 0 開始，沒有人交棒給 0，所以 <code>main()</code> 要自己丟。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fizzbuzz.streamBaton &lt;- <span class="number">0</span> <span class="comment">//啟動交棒</span></span><br></pre></td></tr></table></figure><p>再來，本題不像之前有清楚的交接棒順序，不預設哪一個 goroutine 會收尾，所以需要用 <code>sync.WaitGroup</code> 同步 4 個 goroutine 結束時間。</p><p>最後，由於最後一個 print 交出去的棒子沒 goroutine 接，所以要記得關閉通道，否則在交棒點會發生 deadlock。（你想知道後果的話，可以在下面原始碼自行把 close 這行註解掉看看）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(fizzbuzz.streamBaton)</span><br></pre></td></tr></table></figure><h4 id="交接棒流程：PrintLoop-視角">交接棒流程：PrintLoop() 視角</h4><p>這一次採用去中心化的交棒決策，所以每一個 goroutine 的流程都是相同的，因此我將各自的「整除條件」<code>PassCondition(i int)bool</code>與「字串輸出」<code>PrintString(i int)</code>取出，以下列程式碼 <code>PrintFizz()</code> 為例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FizzBuzz)</span> <span class="title">PrintFizz</span><span class="params">()</span></span> &#123;</span><br><span class="line">PassCondition := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> (<span class="number">0</span> == i%<span class="number">3</span>) &amp;&amp; (<span class="number">0</span> != i%<span class="number">5</span>) &#125;</span><br><span class="line">PrintString := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123; fmt.Printf(<span class="string">&quot;Fizz(%d), &quot;</span>, i) &#125;</span><br><span class="line"></span><br><span class="line">this.PrintLoop(PassCondition, PrintString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的 <code>PrintBuzz()</code>、<code>PrintFizzBuzz()</code>、<code>PrintNumber()</code> 也都比照辦理。剩下都抽象為 <code>PrintLoop()</code> 以達到程式碼的 DRY，如下列程式碼：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FizzBuzz)</span> <span class="title">PrintLoop</span><span class="params">(passCondition <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>, <span class="title">printString</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> this.wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= this.n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> passCondition(i) &#123;</span><br><span class="line">nextNum := &lt;-this.streamBaton <span class="comment">//接棒</span></span><br><span class="line"><span class="keyword">if</span> i == nextNum &#123;</span><br><span class="line">printString(i)</span><br><span class="line">this.streamBaton &lt;- i + <span class="number">1</span> <span class="comment">//交棒</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.streamBaton &lt;- nextNum <span class="comment">//把數字還回去</span></span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for loop 會獨自判斷 0~n 每一個數字是否滿足自己要輸出的條件？</p><ol><li>若滿足，就去公共的 channel <code>streamBaton</code> 裡頭看看，有沒有剛好與 i 相同的數字？<ul><li>若有，表示有某未知 goroutine 交棒給自己了，便可以輸出。輸出以後要交棒，只知道下一棒的數字會+1，但並不知道誰接棒？反正把棒子丟回去公共的 channel <code>streamBaton</code> 讓該接棒的自己接棒。</li><li>若無，表示這次讀取沒命中、表示自己還沒接到棒，要把數字再寫回 channel 讓應該接這一棒的 goroutine 可以讀取到這筆資訊。<code>i--</code> 使 for loop 不會前進，繼續原地等待接棒。</li></ul></li><li>動作完成後，要執行 <code>runtime.Gosched()</code>，使自己不會獨佔 CPU，令其他 goroutine 有機會可以動作。</li></ol><h3 id="3-「不要透過共享來通訊，而要透過通訊來共享」">3.「不要透過共享來通訊，而要透過通訊來共享」</h3><p>過去幾次解題都用 unbuffered channel 的原因是，並沒有要共享什麼資料，就只要在 goroutine 之間交接棒，這個棒子上不需要帶其他訊息，因此 channel 用的也比較多，因為「交棒給誰？」的訊息用多個不同 topic 的 channel 區別。</p><p>這一次採用 buffered channel，是因為不只要交接棒了，還要透過一個 int 來指定下一個交接對象，這就是「透過通訊來共享」。</p><p>當我們要把一件事講清楚，除了講「應該是什麼」，最好也把「不應該是什麼」說明白，正反例都有更有助於建立清晰的認知。</p><p>那麼，要是我就故意反著做，硬要「透過共享來通訊」呢？很簡單，把 <code>chan int</code> 改成 <code>int</code>，其他部分做些相應修改就是了。兩個版本的程式碼都會放在下面的 The Go Playground 連結。</p><p>但是這兩種方法，在本題的執行結果卻完全相同！花費時間也沒有明顯差異。所以「透過通訊來共享」的優越性到底在哪裡？或許本題的要求不夠嚴苛，不足以展示出差異，而筆者自己也學藝不精，尚未參透。如果有讀者能說得清楚，歡迎在本文底下留言，筆者會非常感謝你。</p><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p>「透過通訊來共享」版本（使用 chan int）:<br><a href="https://play.golang.org/p/nHZtkI-pGs5">https://play.golang.org/p/nHZtkI-pGs5</a></p><p>「透過共享來通訊」版本（使用 int）:<br><a href="https://play.golang.org/p/92wshFYlPG3">https://play.golang.org/p/92wshFYlPG3</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/FizzBuzzMultithreaded%E7%A4%BA%E6%84%8F%E5%9C%9620200223.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次將會示範 goroutine 教學中常講到的「不要透過共享來通訊，而要透過通訊來共享」。&lt;/p&gt;
&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>select-case-default 忘記讓出 CPU 的地雷，只在我電腦上能跑的程式</title>
    <link href="https://mosdeo.github.io/2020/01/21/select-case-default%E5%BF%98%E8%A8%98%E8%AE%93%E5%87%BACPU%E7%9A%84%E5%9C%B0%E9%9B%B7%EF%BC%8C%E5%8F%AA%E5%9C%A8%E6%88%91%E9%9B%BB%E8%85%A6%E4%B8%8A%E8%83%BD%E8%B7%91%E7%9A%84%E7%A8%8B%E5%BC%8F/"/>
    <id>https://mosdeo.github.io/2020/01/21/select-case-default%E5%BF%98%E8%A8%98%E8%AE%93%E5%87%BACPU%E7%9A%84%E5%9C%B0%E9%9B%B7%EF%BC%8C%E5%8F%AA%E5%9C%A8%E6%88%91%E9%9B%BB%E8%85%A6%E4%B8%8A%E8%83%BD%E8%B7%91%E7%9A%84%E7%A8%8B%E5%BC%8F/</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-01-22T06:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>這一篇其實是為了要補充上一篇<a href="https://mosdeo.github.io/2020/01/21/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintZeroEvenOdd/">「LeetCode Concurrency Go 語言詳解：Print Zero Even Odd」</a>沒寫到的細節，但所要解釋的概念，是針對 mulit-channel 管理上可能會犯的錯誤，與 LeetCode 比較沒關係，只是我剛好在解這一題 LeetCode 時學到的，所以最後決定將這部分獨立成一篇文章介紹。</p><p>為什麼說是地雷？當程式在自己的電腦上正常，我會很容易以為自己是對的，而且這個現象與作業系統的排程細節有關，很難找一個明確的環境原因。</p><h2 id="補充：我踩到的-select-case-default-地雷">補充：我踩到的 select-case-default 地雷</h2><p>你可以看到，我的解題程式碼 default 那段是這麼寫的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line">runtime.Gosched()</span><br><span class="line"><span class="comment">//&lt;-time.After(time.Microsecond)</span></span><br><span class="line">i--</span><br></pre></td></tr></table></figure><p>以上其實是被高人「指點」後的。原本是這麼寫：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line">i--</span><br></pre></td></tr></table></figure><p>這樣在我的 MacBook 依然正常，但是拿到 The Go Playground 上面就掛了，你可以自己修改程式碼（那篇解題文章最後有程式連結），在 The Go Playground 上試看看會怎樣？</p><hr><p>原因是，雖然 select-case-default 會隨機均勻的嘗試每一個 case-default，但是並不會主動把 CPU 控制權交出去，需要用 <code>runtime.Gosched()</code> 或 <code>&lt;-time.After(time.Microsecond)</code> 把 CPU 讓出給其他 goroutine。否則，其他的 goroutine 將可能沒有機會動作。</p><p>C# 裡的 <code>Application.DoEvents()</code> 也是一樣的意思，讓別的事件有機會被觸發。</p><hr><p>那為什麼我的 MacBook 正常跑完？難道是 CPU 使用數量限制嗎？我們來看看這兩個平台可用的邏輯處理器數量：</p><ul><li>The Go Playground: runtime.NumCPU=1</li><li>MacBook Air 2018:  runtime.NumCPU=4</li></ul><p>好的，我的 MacBook 果然有比較多邏輯處理器可用，但也不足以說明這就是原因。</p><p>於是，我索性在筆電上的程式碼開頭加上一行 <code>runtime.GOMAXPROCS(1)</code> 限制此程式與 The Go Playground 一樣，只能用一個邏輯 CPU。結果，字出來是變慢了，好像古老的打字機那樣，但也是順利正確的跑完了，無法重現 The Go Playground 上發生的錯誤。所以這樣的 bug，真的很難在不同平台上重現，是很不容易發現的地雷。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這一篇其實是為了要補充上一篇&lt;a href=&quot;https://mosdeo.github.io/2020/01/21/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintZeroEvenOdd/&quot;</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：Print Zero Even Odd</title>
    <link href="https://mosdeo.github.io/2020/01/20/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintZeroEvenOdd/"/>
    <id>https://mosdeo.github.io/2020/01/20/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintZeroEvenOdd/</id>
    <published>2020-01-20T16:00:00.000Z</published>
    <updated>2020-02-10T01:50:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我寫的第三題 LeetCode Concurrency Go 語言詳解，技術比前面兩題都要複雜。為了解釋到我自認夠清楚，寫的時間多花了好幾倍（1x = 2hr）。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/print-zero-even-odd/">https://leetcode.com/problems/print-zero-even-odd/</a></p><h2 id="本題題目">本題題目</h2><blockquote><p>The same instance of ZeroEvenOdd will be passed to three different threads:</p></blockquote><p>同一個 instance <code>ZeroEvenOdd</code> 會被傳到三個 thread 裡面:</p><blockquote><p>Thread A will call zero() which should only output 0’s.<br>Thread B will call even() which should only ouput even numbers.<br>Thread C will call odd() which should only output odd numbers.</p></blockquote><p>Thread A 將會呼叫 <code>zero()</code> 並且只會輸出 0<br>Thread B 將會呼叫 <code>even()</code> 並且只會輸出偶數<br>Thread C 將會呼叫 <code>odd()</code> 並且只會輸出奇數</p><blockquote><p>Each of the threads is given a printNumber method to output an integer. Modify the given program to output the series 010203040506… where the length of the series must be 2n.</p></blockquote><p>每一個 thread 都會被傳入一個 <code>printNumber()</code> 以輸出一個整數。<br>修改已給的程式碼，使其輸出序列為 010203040506…，該序列長度必須為 2n。</p><h2 id="本題考核難點？">本題考核難點？</h2><p>在一個未知長度的序列中，依照「0-奇數-0-偶數」的順序將數字印出，且一種元素只能由一個執行緒印出，代表各個執行緒之間要依照這個數列的規則溝通。</p><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 順序控制的能力。</p><p>與前面幾題不同的是，這一題最後工作的 thread 具有不確定性，視數列最後一個元素為奇數或偶數來決定，這點小小的提高了難度。</p><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><p>本題採用五個 unbuffered channel，並且是 <code>ZeroEvenOdd</code> 的成員變數。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ZeroEvenOdd <span class="keyword">struct</span> &#123;</span><br><span class="line">n                <span class="keyword">int</span></span><br><span class="line">streamEvenToZero <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamOddToZero  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamZeroToEven <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamZeroToOdd  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamZeroToEnd  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zeo = &amp;ZeroEvenOdd&#123;</span><br><span class="line">n:                testNum,</span><br><span class="line">streamEvenToZero: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">streamOddToZero:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">streamZeroToEven: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">streamZeroToOdd:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">streamZeroToEnd:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位分別是:</p><ul><li><code>streamEvenToZero</code>: <code>Even()</code> 交棒給 <code>Zero()</code></li><li><code>streamOddToZero</code>: <code>Odd()</code> 交棒給 <code>Zero()</code></li><li><code>streamZeroToEven</code>: <code>Zero()</code> 交棒給 <code>Even()</code></li><li><code>streamZeroToOdd</code>: <code>Zero()</code> 交棒給 <code>Odd()</code></li><li><code>streamZeroToEnd</code>: <code>Zero()</code> 交棒給啟動它的 goroutine</li></ul><h3 id="2-五個-goroutine-之間，如何交接棒？">2. 五個 goroutine 之間，如何交接棒？</h3><h4 id="自循環-外部啟動注意事項">自循環 &amp; 外部啟動注意事項</h4><p>以前的文章說過，由於本題解法採用各個 goroutine 彼此循環交棒的方式，因此不能自行啟動，需要外界給訊號，所以在包住一整題的 <code>PrintZeroEvenOdd()</code> 執行各個 <code>goroutine</code> 同時以 <code>zeo.streamEvenToZero &lt;- struct&#123;&#125;&#123;&#125;</code> 作為起頭的火種 ，讓 <code>main()</code> 假裝自己是 <code>Even()</code> 交棒給 <code>Zero()</code>，以啟動交接棒循環。具體程式碼如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; zeo.streamEvenToZero &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;() <span class="comment">//給起頭的火種</span></span><br><span class="line"><span class="keyword">go</span> zeo.Zero(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Even(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Odd(PrintNumber)</span><br></pre></td></tr></table></figure><p>要特別注意的是，這個「啟動火種」也要寫成 goroutine，否則會由於執行當下尚未等到消費者「出世」，發生 deadlock！</p><p>另外一種不用 goroutine 啟動的做法，也可以讓消費者先「出世」，在 goroutine 的阻塞中等待時，再給「啟動火種」。具體程式碼如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> zeo.Zero(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Even(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Odd(PrintNumber)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; zeo.streamEvenToZero &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;() <span class="comment">//給起頭的火種</span></span><br></pre></td></tr></table></figure><h4 id="交接棒流程：Zero-視角">交接棒流程：Zero() 視角</h4><p>中心化：由 <code>Zero()</code> 做控管中心，遍歷 0 to n 每一個數字，印完自己責任該印的 “0” 以後，根據數字性質決定要把棒子交給 <code>Even()</code> 或 <code>Odd()</code>。此處會用到 select-case-default。具體程式碼如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ZeroEvenOdd)</span> <span class="title">Zero</span><span class="params">(printNumber <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; this.n; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-this.streamOddToZero:</span><br><span class="line">printNumber(<span class="number">0</span>)</span><br><span class="line">this.streamZeroToEven &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-this.streamEvenToZero:</span><br><span class="line">printNumber(<span class="number">0</span>)</span><br><span class="line">this.streamZeroToOdd &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">runtime.Gosched()</span><br><span class="line"><span class="comment">//&lt;-time.After(time.Microsecond)</span></span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> == this.n%<span class="number">2</span> &#123;</span><br><span class="line">&lt;-this.streamEvenToZero <span class="comment">//等待 Even() 結束，自己再結束</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&lt;-this.streamOddToZero <span class="comment">//等待 Odd() 結束，自己再結束</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>雖然順序都是固定的，但在此先假裝 <code>Zero()</code> 並不知道誰會交棒給自己？所以 <code>Zero()</code> 交棒（send to chan）以後，就會在 for-select 裡無窮迴圈，每一次 select{} 都會隨機選擇一個 case 或 default，也就是以亂槍打鳥的方式 polling 是誰交棒給自己？</p><blockquote><p>謎之聲：「難道有不是中心化的流程嗎？」，有喔！我解決「DiningPhilosophers」這一題用的就是去中心化方法，但目前還沒寫那一題詳解。</p></blockquote><h4 id="交接棒流程：Even-Odd-視角">交接棒流程：Even() &amp; Odd() 視角</h4><p>對於 <code>Even()</code> 與 <code>Odd()</code> 來說，流程很固定，只有 <code>Zero()</code> 會交棒給自己，印完數字後，也只需要交棒給同樣的 <code>Zero()</code> ，一種「哪裡來，就哪裡去」的概念。</p><p>唯一比較複雜的部分，就是數字「遞增」與「終點」的控制：</p><ul><li>「遞增」每一次都是 += 2，不必解釋。</li><li>「終點」一開始就算好題目下的奇數上限、偶數上限，算法看程式碼也很清楚了，不解釋。超過終點就直接結束。</li></ul><p>具體程式碼如下（太相似，故此處只放 <code>Even()</code> 舉例）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ZeroEvenOdd)</span> <span class="title">Even</span><span class="params">(printNumber <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">evenUpper := this.n - this.n%<span class="number">2</span></span><br><span class="line"><span class="comment">// fmt.Println(&quot;evenUpper:&quot;, evenUpper)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= evenUpper; &#123;</span><br><span class="line">&lt;-this.streamZeroToEven</span><br><span class="line">printNumber(i)</span><br><span class="line">i += <span class="number">2</span></span><br><span class="line">this.streamEvenToZero &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收尾之一：為什麼要-Zero-善後？">收尾之一：為什麼要 <code>Zero()</code> 善後？</h4><p>由於題目的關係，<code>Even()</code> 或 <code>Odd()</code> 其中一個，都有可能是最後印出字元的 goroutine，若讓這兩者去收尾，流程上的不確定性比較大。因此，幾經考慮後，還是決定讓 <code>Zero()</code> 去收尾。</p><p>讓 <code>Zero()</code> 去收尾的套路，之前的詳解也寫過，就是先 return 的 goroutine 最後都要 send to chan 到負責收尾的 goroutine，收尾 goroutine 在最後一一將這些 chan 都 receive 掉。</p><p>但由於本題特性，可由題目給定數字的奇偶判斷，<code>Zero()</code> 會從哪個 channnel 收到收尾訊號？因此在 <code>Zero()</code> 最後段的 receive，是以奇偶數判斷要在何處等待。具體的局部程式碼如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0</span> == this.n%<span class="number">2</span> &#123;</span><br><span class="line">&lt;-this.streamEvenToZero <span class="comment">//等待 Even() 結束，自己再結束</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&lt;-this.streamOddToZero <span class="comment">//等待 Odd() 結束，自己再結束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收尾之二：代替-sync-WaitGroup-Wait-的「chan-receive-阻塞法」">收尾之二：代替 sync.WaitGroup.Wait() 的「chan receive 阻塞法」</h4><p>主程式為了等待 goroutine 都結束才往下的同步情況，往往會用 <code>sync.WaitGroup.Wait()</code>。<br>根據本文前面所介紹，我已經將流程結束的不確定性減少，使得一定會由 <code>Zero()</code> 負責收尾，因此只要在主程式阻塞一個 chan receive，由 <code>Zero()</code> 結束前 send 一下，便可以將主程式打通，繼續往下。</p><p>具體的局部程式碼如下：</p><p>goroutine <code>Zero()</code> 結束前 send 一下，交棒出去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ZeroEvenOdd)</span> <span class="title">Zero</span><span class="params">(printNumber <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="comment">//.....略過多行</span></span><br><span class="line">this.streamZeroToEnd &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主程式啟動完其他 goroutine 之後，阻塞一個 chan receive，等待被 <code>Zero()</code> 打通，繼續往下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> zeo.Zero(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Even(PrintNumber)</span><br><span class="line"><span class="keyword">go</span> zeo.Odd(PrintNumber)</span><br><span class="line">&lt;-zeo.streamZeroToEnd <span class="comment">//等待 Zero() 送出結束訊號</span></span><br></pre></td></tr></table></figure><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p><a href="https://play.golang.org/p/K5ZpQsHxlfN">https://play.golang.org/p/K5ZpQsHxlfN</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/PrintZeroEvenOdd%E7%A4%BA%E6%84%8F%E5%9C%9620200121.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我寫的第三題 LeetCode Concurrency Go 語言詳解</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：Print In Order</title>
    <link href="https://mosdeo.github.io/2020/01/18/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintInOrder/"/>
    <id>https://mosdeo.github.io/2020/01/18/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintInOrder/</id>
    <published>2020-01-18T16:00:00.000Z</published>
    <updated>2020-02-10T01:50:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我試水溫的第二篇。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/print-in-order/">https://leetcode.com/problems/print-in-order/</a></p><h2 id="本題考核點？">本題考核點？</h2><p>指定各種不同順序執行 <code>First()</code>, <code>Second()</code>, <code>Third()</code> 三個 goroutine，但三者都必須以不變順序印出字串，印出順序不受順序執行影響。</p><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 順序控制的能力。</p><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><p>本題採用三個 unbuffered channel，並且串在一個 slice 裡。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make an array of unbuffered</span></span><br><span class="line"><span class="keyword">var</span> streamSync [<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> streamSync &#123;</span><br><span class="line">streamSync[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分別是:</p><ul><li><code>streamSync[0]</code>: <code>First()</code> 交棒給 <code>Second()</code></li><li><code>streamSync[1]</code>: <code>Second()</code> 交棒給 <code>Third()</code></li><li><code>streamSync[2]</code>: <code>Third()</code> 交棒給 <code>PrintInOrder()</code></li></ul><h3 id="2-三個-或說四個-goroutine-之間，如何交接棒？">2. 三個(或說四個) goroutine 之間，如何交接棒？</h3><p>一開始由 <code>PrintInOrder()</code> 依照指定順序啟動三個 goroutine。</p><p>再看這三個 goroutine，只有 <code>First()</code> 可以不受限執行 Print，其餘都必須等待各自的 <code>streamSync[i]</code> 訊號，因此可以保證 “First” 先被印出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(streamSync [3]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;First&quot;</span>)</span><br><span class="line">streamSync[<span class="number">0</span>] &lt;- <span class="literal">nil</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Second</span><span class="params">(streamSync [3]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&lt;-streamSync[<span class="number">0</span>]</span><br><span class="line">fmt.Print(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line">streamSync[<span class="number">1</span>] &lt;- <span class="literal">nil</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Third</span><span class="params">(streamSync [3]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&lt;-streamSync[<span class="number">1</span>]</span><br><span class="line">fmt.Print(<span class="string">&quot;Third&quot;</span>)</span><br><span class="line">streamSync[<span class="number">2</span>] &lt;- <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>當 “First” 先被印出之後，交棒給 <code>streamSync[0]</code>，然後…</p><ul><li>被 <code>streamSync[0]</code> 卡住的 <code>Second()</code> 就可以印出 “Second”</li><li>被 <code>streamSync[1]</code> 卡住的 <code>Third()</code> 繼續等待訊號</li><li>被 <code>streamSync[2]</code> 卡住的 <code>PrintInOrder()</code> 繼續等待訊號</li></ul></li><li><p>當 “Second” 繼續被印出之後，交棒給 <code>streamSync[1]</code>，然後…</p><ul><li>被 <code>streamSync[1]</code> 卡住的 <code>Third()</code> 就可以印出 “Third”</li><li>被 <code>streamSync[2]</code> 卡住的 <code>PrintInOrder()</code> 繼續等待訊號</li></ul></li><li><p>當 “Third” 最後被印出之後，交棒給 <code>streamSync[2]</code>，然後…</p><ul><li>被 <code>streamSync[2]</code> 卡住的 <code>PrintInOrder()</code> 就可以往下執行，最後程式順利結束。</li></ul></li></ol><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p>本題解答程式碼已經窮舉這三個 goroutine 所有啟動順序。</p><p><a href="https://play.golang.org/p/cklu-vaxF6w">https://play.golang.org/p/cklu-vaxF6w</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/PrintInOrder%E7%A4%BA%E6%84%8F%E5%9C%9620200119.JPG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我試水溫的第二篇。&lt;/p&gt;
&lt;h2 id=&quot;本題-LeetCode-連</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Concurrency Go 語言詳解：Print FooBar Alternately</title>
    <link href="https://mosdeo.github.io/2020/01/15/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintFooBarAlternately/"/>
    <id>https://mosdeo.github.io/2020/01/15/LeetCode_Concurrency_Go%E8%AA%9E%E8%A8%80%E8%A9%B3%E8%A7%A3_PrintFooBarAlternately/</id>
    <published>2020-01-15T16:00:00.000Z</published>
    <updated>2020-02-10T01:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我試水溫的第一篇。</p><h2 id="本題-LeetCode-連結：">本題 LeetCode 連結：</h2><p><a href="https://leetcode.com/problems/print-foobar-alternately/">https://leetcode.com/problems/print-foobar-alternately/</a></p><h2 id="本題考核點？">本題考核點？</h2><p>指定次數交替執行 <code>printFoo()</code> 與 <code>printBar()</code>。若任由兩個 goroutine 分別各自 print，不能保證其結果一定會互相交錯。</p><p>goroutine 若不刻意控制，將無法保證執行的先後順序，因此本題就是要考核對 goroutine 來回交錯順序控制的能力。</p><h2 id="解法與思路：">解法與思路：</h2><h3 id="1-所用-Channel-型態與定位？">1. 所用 Channel 型態與定位？</h3><p>本題採用三個 unbuffered channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FooBar <span class="keyword">struct</span> &#123;</span><br><span class="line">n              <span class="keyword">int</span></span><br><span class="line">streamFooToBar <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamBarToFoo <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">streamEnd      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分別是:</p><ul><li><code>streamFooToBar</code>: <code>Foo()</code> 交棒給 <code>Bar()</code></li><li><code>streamBarToFoo</code>: <code>Bar()</code> 交棒給 <code>Foo()</code></li><li><code>streamEnd</code>: 結束訊號</li></ul><h3 id="2-Foo-與-Bar-如何交接棒？">2. <code>Foo()</code> 與 <code>Bar()</code> 如何交接棒？</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FooBar)</span> <span class="title">Foo</span><span class="params">(printFoo <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; this.n; &#123;</span><br><span class="line"><span class="comment">// printFoo() outputs &quot;foo&quot;. Do not change or remove this line.</span></span><br><span class="line">&lt;-this.streamBarToFoo</span><br><span class="line">printFoo()</span><br><span class="line">i++</span><br><span class="line">this.streamFooToBar &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-this.streamBarToFoo <span class="comment">//等待 Bar() 印完最後一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根據設定次數 n 重複執行</li><li>每一輪都要得到 <code>Bar()</code> 交出棒，才會執行 <code>printFoo()</code> 以印出字串</li><li>印出字串後，以 <code>this.streamFooToBar &lt;- struct&#123;&#125;&#123;&#125;</code> 交棒給 <code>Bar()</code></li></ul><p>下方的 <code>Bar()</code> 也是一樣的道理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FooBar)</span> <span class="title">Bar</span><span class="params">(printBar <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; this.n; &#123;</span><br><span class="line"><span class="comment">// printBar() outputs &quot;bar&quot;. Do not change or remove this line.</span></span><br><span class="line">&lt;-this.streamFooToBar</span><br><span class="line">printBar()</span><br><span class="line">i++</span><br><span class="line">this.streamBarToFoo &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.streamEnd &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Foo-與-Bar-如何收尾？">3. <code>Foo()</code> 與 <code>Bar()</code> 如何收尾？</h3><p>這裡要特別注意的是，<code>Foo()</code> 與 <code>Bar()</code> 只有差異在最後一行，用意是什麼？</p><p>多個 goroutine 用 unbuffered channel 互相交接棒，會有一個尷尬的情況，就是互為消費者、又互為生產者，因此先 return 的 goroutine 沒事，但是後 return 的 goroutine 會由於消費者消失，send to channel 的時候發生 Deadlock。</p><p>根據本題遊戲規則， <code>printBar()</code> 一定要比 <code>printFoo()</code> 晚執行，因此不做特別處理的話，會在 <code>Bar()</code> 試圖做最後一次交棒時，由於消費者消失發生 Deadlock。</p><p>我的應對方式，就是讓 <code>Foo()</code> return 前做一次無特別作用的接棒，這樣就可以避免 <code>Bar()</code> return 前找不到消費者的問題。</p><h3 id="4-自循環啟動">4. 自循環啟動</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fooBar.streamBarToFoo &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//啟動</span></span><br></pre></td></tr></table></figure><p>前面說過，本題解法採用 <code>Foo()</code> 與 <code>Bar()</code> 彼此循環交棒的方式，因此不能自行啟動，需要外界給訊號，所以在 <code>main()</code> 執行各個 <code>goroutine</code> 以後以 <code>fooBar.streamBarToFoo &lt;- struct&#123;&#125;&#123;&#125;</code> ，讓 <code>main()</code> 假裝自己是 <code>Bar()</code> 交棒給 <code>Foo()</code>，以啟動交接棒循環。</p><h3 id="5-特別條件下，用-unbuffered-channel-取代-sync-WaitGroup">5. 特別條件下，用 unbuffered channel 取代 sync.WaitGroup</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-fooBar.streamEnd                  <span class="comment">//as wg.Wait()</span></span><br></pre></td></tr></table></figure><p>為了等待多個 goroutine 都結束再往下，一般來說用 <code>sync.WaitGroup.Wait()</code> 是標準做法。但這一題還有更輕量的方法。</p><p>雖然這一題是 Concurrency，但是各個 goroutine 的結束順序已經被定死，我們很清楚知道誰負責收尾，所以讓負責收尾的 goroutine send to unbuffered channel，然後在 <code>main()</code> read 掉，這樣就不需要使用 sync.WaitGroup</p><p>執行各個 goroutine 以後，<code>main()</code> 會由於 <code>&lt;-fooBar.streamEnd</code> 還沒有被傳入而被卡住，這就相當於 <code>sync.WaitGroup.Wait()</code> 的作用了。</p><p>由於是 <code>Bar()</code> 會做最後一次有意義的執行，因此讓 <code>Bar()</code> return 之前執行 <code>this.streamEnd &lt;- struct&#123;&#125;&#123;&#125;</code>，這就相當於交棒給 <code>main()</code>， <code>main()</code> 終於可以從被卡住的 <code>&lt;-fooBar.streamEnd</code> 往下（因為終於有東西可以讀），就像便秘了三天突然暢通一樣！</p><h2 id="完整解題程式碼：">完整解題程式碼：</h2><p><a href="https://play.golang.org/p/YsXKHbxpOCT">https://play.golang.org/p/YsXKHbxpOCT</a></p><h2 id="示意圖：">示意圖：</h2><p><img src="/content/images/leetcode/PrintFooBarAlternately%E7%A4%BA%E6%84%8F%E5%9C%9620200116.PNG" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：由於 LeetCode Concurrency(併發) 還沒有 Go 語言版本，我先自行用 Go 語言來解題。為了能在 LeetCode 以外的平台獲得討論，所以我打算逐漸把自己的解題思路寫下。這是我試水溫的第一篇。&lt;/p&gt;
&lt;h2 id=&quot;本題-LeetCode-連</summary>
      
    
    
    
    
    <category term="Go語言" scheme="https://mosdeo.github.io/tags/Go%E8%AA%9E%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>解決在 macOS 上安裝 OpenCV 遇到「‘opencv2/opencv.hpp’ file not found」地雷</title>
    <link href="https://mosdeo.github.io/2019/10/09/%E5%9C%A8%20macOS%20%E4%B8%8A%E5%AE%89%E8%A3%9D%20OpenCV%20%E9%81%87%E5%88%B0%E7%9A%84%E5%9C%B0%E9%9B%B7/"/>
    <id>https://mosdeo.github.io/2019/10/09/%E5%9C%A8%20macOS%20%E4%B8%8A%E5%AE%89%E8%A3%9D%20OpenCV%20%E9%81%87%E5%88%B0%E7%9A%84%E5%9C%B0%E9%9B%B7/</id>
    <published>2019-10-09T16:00:00.000Z</published>
    <updated>2019-10-10T11:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>安裝 OpenCV 一直都是堪稱玄學的技術，猶記得我大四第一次入門花了兩週才安裝成功，其中一個原因是我自己對「編譯、連結、載入、執行」不熟悉，這也是我技能樹有待補強的地方。</p><p>是說，這麼多年過去了，Windows 和 Linux 上我也安裝了無數次，EmguCV 也搞得定，換到上 macOS 仍須鬼打牆一整天才找到解方。</p><p>錯誤如下：</p><blockquote><p>fatal error: ‘opencv2/opencv.hpp’ file not found</p></blockquote><hr><h2 id="檢查編譯設定">檢查編譯設定</h2><p>我又反覆檢查 VSCode 中 task.json 的編譯設定，確認給出的路徑裡的確有 libs</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;clang++&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">            <span class="comment">//&quot;main(regression_demo).cpp&quot;,</span></span><br><span class="line">            <span class="comment">//&quot;main(classification_demo).cpp&quot;,</span></span><br><span class="line">            <span class="string">&quot;libLKYDeepNN/InputLayer.cpp&quot;</span>,<span class="string">&quot;libLKYDeepNN/HiddenLayer.cpp&quot;</span>,<span class="string">&quot;libLKYDeepNN/OutputLayer.cpp&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-Wall&quot;</span>,</span><br><span class="line">            <span class="comment">//&quot;-v&quot;,</span></span><br><span class="line">            <span class="string">&quot;-pthread&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-I /usr/local/Cellar/opencv/4.1.1_2/lib/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-lopencv_core&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-lopencv_highgui&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-lopencv_imgproc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-std=c++11&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-Ofast&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">            <span class="string">&quot;LKYDeepNN&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="透過-IntelliSense-驗證-includePath-正確性">透過 IntelliSense 驗證 includePath 正確性</h2><p>而我在 c_cpp_properties.json 中給 IntelliSense 的 includePath 是這樣，</p><blockquote><p>/usr/local/Cellar/opencv/4.1.1_2/include/opencv4/**</p></blockquote><p>IntelliSense 能正確識別叫出 namespace cv 底下的東西，所以也驗證了是正確的。</p><hr><h2 id="失敗：改-include">失敗：改 include</h2><p>如果我把 include 從這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>改成這樣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv4/opencv2/opencv.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>的話，「fatal error: ‘opencv2/opencv.hpp’ file not found」會消失，但是換成其他的更深層的 OpenCV hpp 找不到 include。</p><p>別忘了要改回來。</p><hr><h2 id="成功解決：soft-link">成功解決：soft link</h2><p>最後發現，在 /usr/local/inlcude 建立一個 softlink 指向 opencv2，就可以成功編譯。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/include/opencv4/opencv2 opencv2</span><br></pre></td></tr></table></figure><p>是解決了，但我依然說不清楚誰去參考了「/usr/local/include/opencv2」因此得到錯誤或正確的結果。</p><p>參考來源：https://blog.csdn.net/a13602955218/article/details/101625857</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安裝 OpenCV 一直都是堪稱玄學的技術，猶記得我大四第一次入門花了兩週才安裝成功，其中一個原因是我自己對「編譯、連結、載入、執行」不熟悉，這也是我技能樹有待補強的地方。&lt;/p&gt;
&lt;p&gt;是說，這麼多年過去了，Windows 和 Linux 上我也安裝了無數次，EmguCV</summary>
      
    
    
    
    
    <category term="OpenCV" scheme="https://mosdeo.github.io/tags/OpenCV/"/>
    
    <category term="Mac" scheme="https://mosdeo.github.io/tags/Mac/"/>
    
    <category term="除錯" scheme="https://mosdeo.github.io/tags/%E9%99%A4%E9%8C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Charlotte 碳排放評估案例</title>
    <link href="https://mosdeo.github.io/2019/03/19/Charlotte%E7%A2%B3%E6%8E%92%E6%94%BE%E8%A9%95%E4%BC%B0%E6%A1%88%E4%BE%8B/"/>
    <id>https://mosdeo.github.io/2019/03/19/Charlotte%E7%A2%B3%E6%8E%92%E6%94%BE%E8%A9%95%E4%BC%B0%E6%A1%88%E4%BE%8B/</id>
    <published>2019-03-19T16:00:00.000Z</published>
    <updated>2019-09-23T02:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>注意：本文為隨興、無組織的讀書筆記，如果你看不懂我寫什麼是正常的。我只是想記錄一個數據分析的案例。</p><h2 id="摘要">摘要</h2><p>本文為闡述美國環保局對北卡羅萊納州最大的城市－Charlotte，所做的碳排放模擬，想了解＂精明增長（Smart Growth）＂與＂蔓延增長＂兩種土地利用策略對交通設施的變化，進而了解對碳排放的影響。</p><h2 id="原始數據與處理-1-社區特徵聚類">原始數據與處理(1)-社區特徵聚類</h2><ul><li>步行可行性</li><li>可達性</li><li>地塊</li><li>工業區域</li><li>城市屬性值</li></ul><p>將 5 種特徵以 K-means 聚類為 8 種社區類型。</p><h2 id="原始數據與處理-2-人口預測">原始數據與處理(2)-人口預測</h2><ul><li>2003 Woods &amp; Poole 經濟學資料庫</li><li>使用區域預測模型(?)預測到2030年</li><li>3 種外插法預測 2030~2050<ul><li>2029~2030 一次導數</li><li>1991~2030 二次導數</li><li>前兩種方法的綜合，使用 2030 年的二次導數直推到 2050 年</li></ul></li><li>最後，對三種外插法的結果平均</li></ul><h2 id="名詞解釋">名詞解釋</h2><ul><li>TOD(Transit-Oriented Development)：以公共交通为导向的发展</li><li>基礎年：2010 年</li><li>mph：英里每小时。1 mph = 0.44704 m/s</li><li>集計處理(Aggregate)：基於 GIS 單位的 downsample，例如將單位由＂區＂擴大到＂縣市＂。</li><li>美國環保局(EPA)排放因素模組－MOBILE6<ul><li>採用特徵：燃油類型、引擎技術、路段平均速度、設施類型(高速公路、主幹道)、排放控制標準、檢查與維修、環境條件(溫度、濕度、大氣壓力)、車型(輕型車、重型車、公車)與車齡</li></ul></li></ul><h2 id="模擬至2050年的結果">模擬至2050年的結果</h2><ul><li><p>就業（兩方案總就業變化量相同）</p><ul><li>蔓延增長：由市中心向外擴散</li><li>精明增長：由市中心與公車站點向外擴散，形成多中心格局</li></ul></li><li><p>住宅（兩方案總住宅變化量相同）</p><ul><li>蔓延增長：由市中心向外擴散</li><li>精明增長：</li></ul></li><li><p>車輛行駛里程</p><ul><li>蔓延增長/基礎年=97.5%</li><li>精明增長/基礎年=86.7%</li></ul></li><li><p>路網平均行駛速度</p><ul><li>(基礎年,蔓延增長,精明增長) =(42, 33, 35)mph</li></ul></li><li><p>交通行為對比(精明增長：蔓延增長)</p><ul><li>公車乘客里程數：高50%</li><li>小汽車乘客里程數：低6.3%</li><li>步行量：高54%</li><li>公車供給量：多60%</li></ul></li></ul><h2 id="出處">出處</h2><ul><li>宋彦, and 陈燕萍. “城市规划评估指引.” 中国建筑工业出版社(2012). 第十章:信息技术在国外规划评估中的应用。</li><li><a href="http://www.paper.edu.cn/scholar/showpdf/MUT2MN1INTT0Ixxh">宋彦, et al. “城市空间结构对 PM2. 5 的影响——美国夏洛特汽车排放评估项目的借鉴和启示.” 城市规划 5 (2014): 9-14.</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注意：本文為隨興、無組織的讀書筆記，如果你看不懂我寫什麼是正常的。我只是想記錄一個數據分析的案例。&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文為闡述美國環保局對北卡羅萊納州最大的城市－Charlotte，所做的碳排放模擬，想了解＂精明增長（Smart Gro</summary>
      
    
    
    
    
    <category term="GIS" scheme="https://mosdeo.github.io/tags/GIS/"/>
    
    <category term="地理資訊系統" scheme="https://mosdeo.github.io/tags/%E5%9C%B0%E7%90%86%E8%B3%87%E8%A8%8A%E7%B3%BB%E7%B5%B1/"/>
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="機器學習" scheme="https://mosdeo.github.io/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
  </entry>
  
  <entry>
    <title>同事怎麼還不commit🤬別生氣！你們可能踩到 SVN 的大小寫地雷</title>
    <link href="https://mosdeo.github.io/2019/03/13/%E5%90%8C%E4%BA%8B%E6%80%8E%E9%BA%BC%E9%82%84%E4%B8%8D%20commit%EF%BC%81%E5%88%A5%E7%94%9F%E6%B0%A3%EF%BC%8C%E4%BD%A0%E5%8F%AF%E8%83%BD%E8%B8%A9%E5%88%B0%20SVN%20%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%AF%AB%E5%9C%B0%E9%9B%B7/"/>
    <id>https://mosdeo.github.io/2019/03/13/%E5%90%8C%E4%BA%8B%E6%80%8E%E9%BA%BC%E9%82%84%E4%B8%8D%20commit%EF%BC%81%E5%88%A5%E7%94%9F%E6%B0%A3%EF%BC%8C%E4%BD%A0%E5%8F%AF%E8%83%BD%E8%B8%A9%E5%88%B0%20SVN%20%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%AF%AB%E5%9C%B0%E9%9B%B7/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-09-23T02:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/content/images/tortoise-turned-upside.png" alt=""></p><h3 id="今天發生一則狀況">今天發生一則狀況</h3><p>我這邊 update SVN （Git 叫 pull）上的程式碼以後，遲遲編譯不過！</p><p>我就去責問同事 A 你怎麼又忘了把 instance 的宣告上傳？每一次 commit 要注意所有的 change 啊！同事 A 一臉為難又莫名其妙，我回座位去做其他事，等他更新 SVN 上的程式碼。</p><p>過了十幾分鐘，同事 B 又跑來問同事 A 程式碼更新了沒？同事 B 也遇到跟我一樣的狀況。急著要程式碼的同事 B，就叫同事 A 手動把內容傳給他了！</p><p>這就怪了，難道中間這十幾分鐘，同事 A 都在位置上玩手機？</p><hr><h3 id="追查案情">追查案情</h3><ol><li>首先直接看 SVN 上的程式碼，欸~怪了，明明是有更新的！</li><li>我這邊 local 端是否確實 update（Git 叫 pull）？有，reversion 號碼是一樣的。</li><li>往前追查 log，發現這個檔案有被改過檔名，xxx.designer.cs 改成了 xxx.Designer.cs，就改了一個字母 d 的大小寫。</li></ol><p>於是我懷疑，是不是大小寫差異，讓 SVN 看做是不同檔案而出了差錯？</p><hr><h3 id="半個水落石出">半個水落石出</h3><p>搜尋＂Tortoisesvn filename lower case＂，果然有一大堆人有跟我類似經驗。</p><p>Windows 檔名不區分大小寫，但是 SVN 區分大小寫。<br>所以在 Windows 底下，由小寫改過大寫以後，會造成錯亂。<br>我不知道這個錯亂的詳細過程是如何？目前還找不到，只知道會造成該檔案有人可以 commit 上去，別人也可以在 SVN server 上看最新程式碼，但是就沒辦法透過正常的 SVN update 把檔案拉下來。</p><hr><h3 id="避免方法">避免方法</h3><p>下次已經被 add 進 SVN 的檔案，如果要改檔名大小寫，記得要透過 SVN 本身的改名介面，不要直用 Windows 的方法改，不然就會跟我一樣踩到地雷，也委屈了倒楣的同事 A 喔！</p><hr><h3 id="附註">附註</h3><ul><li>基於某些原因，大家不得已在同一個 branch 上開發，所以很容易彼此干擾</li><li>基於某些原因，沒辦法把 SVN 換成 Git，所以很容易被這種事雷到</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/content/images/tortoise-turned-upside.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;今天發生一則狀況&quot;&gt;今天發生一則狀況&lt;/h3&gt;
&lt;p&gt;我這邊 update SVN （Git 叫 pull）上的程式碼以後，遲</summary>
      
    
    
    
    
    <category term="技術" scheme="https://mosdeo.github.io/tags/%E6%8A%80%E8%A1%93/"/>
    
    <category term="版本控制" scheme="https://mosdeo.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>用 Bayesian 推論出地址遺失值</title>
    <link href="https://mosdeo.github.io/2019/01/09/%E7%94%A8Bayseian%E6%8E%A8%E8%AB%96%E5%87%BA%E5%9C%B0%E5%9D%80%E7%BC%BA%E5%A4%B1%E5%80%BC/"/>
    <id>https://mosdeo.github.io/2019/01/09/%E7%94%A8Bayseian%E6%8E%A8%E8%AB%96%E5%87%BA%E5%9C%B0%E5%9D%80%E7%BC%BA%E5%A4%B1%E5%80%BC/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-09-23T02:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/content/images/85%E5%BA%A6C%E5%92%96%E5%95%A1%E8%9B%8B%E7%B3%95.jpg" alt=""></p><h2 id="情境">情境</h2><p>我有一大堆人工輸入的地址清單，可是「XX區」大家經常懶得寫，那我要如何找出「XX區」到底是哪一區呢？</p><h2 id="現況">現況</h2><p>假設要被推論的地址是＂台北市羅斯福路5566號＂，已知訊息如下：</p><ol start="0"><li>該地址新開了一間85度C咖啡店</li><li>羅斯福路只出現在大安區、文山區<s>與中正區</s></li><li>大安區地址數量:文山區地址數量＝5:1</li><li>由[原本地址清單 &amp; 85度C官方網站店鋪清單（註*）]兩份表關聯對比得知，地址為大安區時有85度C的機率為 0.000003，地址為文山區時有85度C的機率為 0.000019<br>註：為什麼不直接從85度C官方網站店鋪清單查詢遺失的「XX區」？有可能這家店是新開的(如假設 0.)，官網資料還沒 update。</li></ol><h2 id="解法">解法</h2><p>根據貝式定理（Bayes’ theorem）</p><blockquote><p>P(該地址在大安區)/P(該地址在文山區)<br>= (P(大安區地址)/P(文山區地址))×(P(85度C|大安區地址)/P(85度C|文山區地址))<br>= 5×(0.000003/0.000019)<br>= 0.7895 倍</p></blockquote><p>結果 &lt; 1，故推論該地址在文山區。</p><h2 id="使用貝式定理的差別在哪裡？">使用貝式定理的差別在哪裡？</h2><p>在此案例中，如果只看地址清單，會推論地址在大安區，因為大安區出現在地址清單中的頻率較高。但由於新增了外部證據，因此推論結果發生改變。</p><h2 id="疑問">疑問</h2><p>Q: 如果那個有問題的地址，剛好不是85度C呢？<br>A: 那就看看有沒有小七、全家、OK等等之類的（先別急著罵我講幹話）。貝式推論本來就是一個「找證據來說話」的過程，因此手上有不同證據，就會得到不同結論，故也有人說「貝式推論本身就帶有偏見」。</p><hr><p>此文章為應用數學假設性探討，以上數據皆為亂掰。如有雷同，純屬巧合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/content/images/85%E5%BA%A6C%E5%92%96%E5%95%A1%E8%9B%8B%E7%B3%95.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;情境&quot;&gt;情境&lt;/h2&gt;
&lt;p&gt;我有一大堆人工輸入的地址清單，可是「XX區」</summary>
      
    
    
    
    
    <category term="數據分析" scheme="https://mosdeo.github.io/tags/%E6%95%B8%E6%93%9A%E5%88%86%E6%9E%90/"/>
    
    <category term="機器學習" scheme="https://mosdeo.github.io/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
    <category term="資料科學" scheme="https://mosdeo.github.io/tags/%E8%B3%87%E6%96%99%E7%A7%91%E5%AD%B8/"/>
    
  </entry>
  
  <entry>
    <title>如何降低食慾又使進食容易有飽足感？</title>
    <link href="https://mosdeo.github.io/2018/12/31/%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E9%A3%9F%E6%85%BE%E5%8F%88%E4%BD%BF%E9%80%B2%E9%A3%9F%E5%AE%B9%E6%98%93%E6%9C%89%E9%A3%BD%E8%B6%B3%E6%84%9F/"/>
    <id>https://mosdeo.github.io/2018/12/31/%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E9%A3%9F%E6%85%BE%E5%8F%88%E4%BD%BF%E9%80%B2%E9%A3%9F%E5%AE%B9%E6%98%93%E6%9C%89%E9%A3%BD%E8%B6%B3%E6%84%9F/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2021-02-02T06:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>這是大學時某堂運動健康相關通識課（課名忘了）的筆記內容，當時授課老師是<a href="http://www.pe.ntnu.edu.tw/members/bio.php?PID=137">王宏豪</a>。</p><p>因為有人問起，所以我寫在這裡。<s>不過筆記放在台灣，我就先憑印象寫，等回台灣再補充。</s> 已經請我妹拍照傳過來了。</p><hr><h2 id="第大一類：大家常聽到的那種">第大一類：大家常聽到的那種</h2><ul><li>吃飯之前先喝湯</li><li>多吃富含纖維的蔬菜</li></ul><hr><h2 id="第大二類：你可能沒聽過的那種">第大二類：你可能沒聽過的那種</h2><h3 id="注意力不要放在食物上類">注意力不要放在食物上類</h3><ul><li>站著吃身體緊張，會更專注食物，要坐著吃</li><li>邊吃邊聊天、吃到分心</li><li>吃飯配電視</li></ul><h3 id="運動也可以節食類">運動也可以節食類</h3><table><thead><tr><th>食慾水準</th><th>中</th><th>低</th><th>中高</th><th>極高</th></tr></thead><tbody><tr><td>生活型態（活動量：低→高）</td><td>坐式生活</td><td>輕微運動</td><td>專業運動員</td><td>體力勞動者</td></tr></tbody></table><h3 id="你以為自己還在餓類">你以為自己還在餓類</h3><ol><li>細嚼慢嚥<ul><li>食道也會容納食物，但是要穿過食道、到達胃的食物才會造成飽足感。吃快與吃慢，產生飽足感時，<strong>食道中的食物量就會不一樣</strong>，這現象也剛好支持一些長輩說「吃八分飽」的理由。</li><li>老師說他曾教過減肥，要求學員吃一支玉米，不能一口一口吃，要一顆一顆吃，學員說一支玉米竟然意外的有飽足感！</li></ul></li></ol><h3 id="食慾節律類">食慾節律類</h3><p>飢餓素有節律性，23點~1點最高峰，所以這段時間最好睡覺。<br>萬一吃了，腸胃蠕動慢、吸收好、易胖、大腸癌風險高。</p><hr><h3 id="附錄：三頁筆記原稿">附錄：三頁筆記原稿</h3><p><img src="/content/images/%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E9%A3%9F%E6%85%BE%E5%8F%88%E4%BD%BF%E9%80%B2%E9%A3%9F%E5%AE%B9%E6%98%93%E6%9C%89%E9%A3%BD%E8%B6%B3%E6%84%9F/%E9%81%8B%E5%8B%95%E8%88%87%E5%81%A5%E5%BA%B7%E6%B8%9B%E8%82%A5%E7%AD%86%E8%A8%981.png" alt=""></p><p><img src="/content/images/%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E9%A3%9F%E6%85%BE%E5%8F%88%E4%BD%BF%E9%80%B2%E9%A3%9F%E5%AE%B9%E6%98%93%E6%9C%89%E9%A3%BD%E8%B6%B3%E6%84%9F/%E9%81%8B%E5%8B%95%E8%88%87%E5%81%A5%E5%BA%B7%E6%B8%9B%E8%82%A5%E7%AD%86%E8%A8%982.png" alt=""></p><p><img src="/content/images/%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E9%A3%9F%E6%85%BE%E5%8F%88%E4%BD%BF%E9%80%B2%E9%A3%9F%E5%AE%B9%E6%98%93%E6%9C%89%E9%A3%BD%E8%B6%B3%E6%84%9F/%E9%81%8B%E5%8B%95%E8%88%87%E5%81%A5%E5%BA%B7%E6%B8%9B%E8%82%A5%E7%AD%86%E8%A8%983.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;這是大學時某堂運動健康相關通識課（課名忘了）的筆記內容，當時授課老師是&lt;a href=&quot;http://www.pe.ntnu.edu.tw/members/bio.php?PID=137&quot;&gt;王宏豪&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因為有人問起，所以我寫在這裡。&lt;s&gt;不過筆記放在台灣</summary>
      
    
    
    
    
    <category term="運動，健康" scheme="https://mosdeo.github.io/tags/%E9%81%8B%E5%8B%95%EF%BC%8C%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>我看中國大陸 Open Source 風氣弱於台灣的原因，心態面＆技術面</title>
    <link href="https://mosdeo.github.io/2018/12/08/%E6%88%91%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E4%B8%AD%E5%9C%8BOpenSource%E9%A2%A8%E6%B0%A3/"/>
    <id>https://mosdeo.github.io/2018/12/08/%E6%88%91%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E4%B8%AD%E5%9C%8BOpenSource%E9%A2%A8%E6%B0%A3/</id>
    <published>2018-12-08T16:00:00.000Z</published>
    <updated>2021-02-02T06:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>基於眾所皆知的原因，本文請到以下 Medium 連結閱讀。</p><p>https://medium.com/@mosdeo/%E6%88%91%E7%9C%8B%E4%B8%AD%E5%9C%8B-open-source-%E9%A2%A8%E6%B0%A3%E5%BC%B1%E6%96%BC%E5%8F%B0%E7%81%A3%E7%9A%84%E5%8E%9F%E5%9B%A0-%E5%BF%83%E6%85%8B%E9%9D%A2-%E6%8A%80%E8%A1%93%E9%9D%A2-da6a9d8d2b57</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基於眾所皆知的原因，本文請到以下 Medium 連結閱讀。&lt;/p&gt;
&lt;p&gt;https://medium.com/@mosdeo/%E6%88%91%E7%9C%8B%E4%B8%AD%E5%9C%8B-open-source-%E9%A2%A8%E6%B0%A3%E5%BC</summary>
      
    
    
    
    
    <category term="大陸" scheme="https://mosdeo.github.io/tags/%E5%A4%A7%E9%99%B8/"/>
    
    <category term="批判" scheme="https://mosdeo.github.io/tags/%E6%89%B9%E5%88%A4/"/>
    
    <category term="開源" scheme="https://mosdeo.github.io/tags/%E9%96%8B%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>聽華工周冬雨分享中國大陸重考生的經驗</title>
    <link href="https://mosdeo.github.io/2018/11/23/%E8%81%BD%E8%8F%AF%E5%B7%A5%E5%91%A8%E5%86%AC%E9%9B%A8%E5%88%86%E4%BA%AB%E4%B8%AD%E5%9C%8B%E9%87%8D%E8%80%83%E7%94%9F%E7%9A%84%E7%B6%93%E9%A9%97/"/>
    <id>https://mosdeo.github.io/2018/11/23/%E8%81%BD%E8%8F%AF%E5%B7%A5%E5%91%A8%E5%86%AC%E9%9B%A8%E5%88%86%E4%BA%AB%E4%B8%AD%E5%9C%8B%E9%87%8D%E8%80%83%E7%94%9F%E7%9A%84%E7%B6%93%E9%A9%97/</id>
    <published>2018-11-23T16:00:00.000Z</published>
    <updated>2021-02-02T06:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天早上游泳完，搭公車去上班的路上，聊了一個神韻相似周冬雨的妹，原來是華南理工大學的食品科學博士生，正要到我公司附近的公務機關辦護照。剛好她出了一些狀況，要辦到下午，所以就約她吃了午餐。<br>　<br><img src="/content/images/%E4%B8%AD%E5%9C%8B%E5%A4%A7%E9%99%B8%E8%A1%97%E6%99%AF/%E8%81%BD%E8%8F%AF%E5%B7%A5%E5%91%A8%E5%86%AC%E9%9B%A8%E5%88%86%E4%BA%AB%E4%B8%AD%E5%9C%8B%E5%A4%A7%E9%99%B8%E9%87%8D%E8%80%83%E7%94%9F%E7%9A%84%E7%B6%93%E9%A9%97.jpg" alt=""></p><p>聊天中得知她曾「复讀高四」，同等於台灣的重考。但中國大陸叫做「复讀」是有原因的，雖然目的與台灣的重考相同，但制度差異下手段有別，「复讀」的確是更貼切的形容。</p><p>在台灣，學籍與升學考試是各自獨立的事務，你脫離學校以後，就算是一個社會人還是可以去考大學；在中國大陸不行，你一定要在高中有學籍才能報考大學，那高中畢業了想重考怎麼辦？你就要找一間願意收你的高中念高四。也會有類似台灣補習班的機構，但是不能幫你報名考大學，也不能像台灣一樣不依靠任何機構自己去報名大學入學考試，這就是中國大陸叫「复讀」而不叫做「重考」的由來。</p><p>Q1：這是高中轉學考嗎？<br>A1：不算。你就想成念高中可以 fork 好了。</p><p>Q2：fork 到另一間高中的高四，就可以再拿一張高中畢業證書?<br>A2：是的，沒錯。</p><p>中國大陸考大學最強的就是「衡水中學」，但若拿台灣的建中來比喻，並不恰當，因為建中可以放飛自我，但衡水中學是軍事化管理，連吃飯都有固定座位、專人打飯收餐盤，吃完就可以空手離開座位、讓你連邊吃邊聊天的機會都沒有。</p><p>這位華工周冬雨當初就想去衡水中學讀高四，但是花了3萬RMB 還不夠（費用依你前次考大學成績決定，若前一次考上北京理工，可能只要花幾千 RMB），還得找關係，找了一位學校裡的主任，談好認他當舅舅再請他吃頓飯就可以，但該位主任最後還是怕出事，反悔了。<br>　<br>這段重考的經歷，對台灣人來說非常特別，但她說，這只是中國大陸复讀生普遍有的經驗而已。</p><p>（照片左邊是當天早上拍的）<br>（照片右邊是受訪者本人）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天早上游泳完，搭公車去上班的路上，聊了一個神韻相似周冬雨的妹，原來是華南理工大學的食品科學博士生，正要到我公司附近的公務機關辦護照。剛好她出了一些狀況，要辦到下午，所以就約她吃了午餐。&lt;br&gt;
　&lt;br&gt;
&lt;img src=&quot;/content/images/%E4%B8%</summary>
      
    
    
    
    
    <category term="大陸" scheme="https://mosdeo.github.io/tags/%E5%A4%A7%E9%99%B8/"/>
    
  </entry>
  
  <entry>
    <title>中國大陸５種行政地雷－辦港澳台人員就業證的經驗</title>
    <link href="https://mosdeo.github.io/2018/09/21/%E4%B8%AD%E5%9C%8B%E5%A4%A7%E9%99%B8%EF%BC%95%E7%A8%AE%E8%A1%8C%E6%94%BF%E5%9C%B0%E9%9B%B7%EF%BC%8D%E8%BE%A6%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%BA%BA%E5%93%A1%E5%B0%B1%E6%A5%AD%E8%AD%89%E7%9A%84%E7%B6%93%E9%A9%97/"/>
    <id>https://mosdeo.github.io/2018/09/21/%E4%B8%AD%E5%9C%8B%E5%A4%A7%E9%99%B8%EF%BC%95%E7%A8%AE%E8%A1%8C%E6%94%BF%E5%9C%B0%E9%9B%B7%EF%BC%8D%E8%BE%A6%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%BA%BA%E5%93%A1%E5%B0%B1%E6%A5%AD%E8%AD%89%E7%9A%84%E7%B6%93%E9%A9%97/</id>
    <published>2018-09-21T16:00:00.000Z</published>
    <updated>2021-02-02T06:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>這是一個「踏破鐵鞋辦文件，得來全不費工夫」的故事。</strong></p><p>上班到一半的時候，剛去幫我辦「港澳台人員就業證」的人資，突然拿了一份讓我傻眼的公文來。公文內容的重點是：</p><blockquote><p>港澳台人員若要在當地就業，必須要多做［霍亂、黃熱、鼠疫、痲瘋、性病、開放性肺結核、愛滋、精神］這8個體檢項目。<img src="/content/images/%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%BA%BA%E5%93%A1%E5%B0%B1%E6%A5%AD%E9%AB%94%E6%AA%A2/IMG_2049.JPG" alt=""> <img src="/content/images/%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%BA%BA%E5%93%A1%E5%B0%B1%E6%A5%AD%E9%AB%94%E6%AA%A2/IMG_2048.JPG" alt=""></p></blockquote><p>這是公司人事要去幫我辦證當下，才碰的壁，並不是事先收到的通知。天啊，這些規定我從來都沒有聽說過！這真的不是我或公司疏忽。後面會提到，是由於一個離譜的原因。</p><br/><h2 id="地雷-1-訊息不透明造成的多餘奔波">地雷 1: 訊息不透明造成的多餘奔波</h2><blockquote><p><strong>在中國大陸許多公家機關辦事都是這樣，往往在網路上查不到官方發布的相關辦理規定，一搜尋都只是各家傳播媒體的相關新聞、或者＂百度知識+＂上路人甲乙丙的回答。打電話去問呢？問到的規定，往往跟現場說的又不同。這不是只有來自境外的台灣人才會遇到的事，我聽過當地人抱怨也不少。</strong></p></blockquote><hr><p>然後，我也沒辦法，只好照辦了。但霍亂、黃熱、鼠疫、痲瘋、性病、開放性肺結核、愛滋、精神病，這些特別的體檢項目要去哪裡檢查呢？辦就業證的地方也順便給了個清單。</p><p><img src="/content/images/%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%BA%BA%E5%93%A1%E5%B0%B1%E6%A5%AD%E9%AB%94%E6%AA%A2/%E5%85%8D%E6%96%BC%E5%85%AC%E9%96%8B%E7%9A%84%E8%81%B2%E6%98%8E_%E5%81%A5%E5%BA%B7%E6%AA%A2%E6%9F%A5%E6%8C%87%E5%BC%95.jpg" alt=""></p><p>其中，<strong>免於公開</strong>的部分，我看了真是傻眼！要給就業大眾的行政命令居然免於公開，這在台灣是不可能發生的事。</p><p>這三家都是同屬於「廣東國際旅行衛生保健中心」底下的分支機構，體檢收費不低，比中國大陸的大醫院還要貴，但是卻有一間「番禺區國際旅行衛生保健中心」是免費的？於是我上網一查，<a href="http://www.gdwbzx.com">官網</a>竟然獨漏這一家的資料。再打電話去問才知道，這一間最晚成立，還沒有設收費機，所以暫不收費。所以我就問清楚要攜帶哪些文件？準備好過去。</p><p>從我上班居住的地方，搭公車轉地鐵、再轉共享單車，到番禺區國際旅行衛生保健中心要兩個小時。</p><p><img src="/content/images/%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%BA%BA%E5%93%A1%E5%B0%B1%E6%A5%AD%E9%AB%94%E6%AA%A2/IMG_20180730_112117.jpg" alt=""></p><p>等我到了以後，櫃檯沒有人，喊了半天才有一個像是路人的大媽蹣跚的走出來。她接走我遞交的文件，看了看以後</p><p>「我们这是免费的，所以只能给在这里就业的人检验」<br>「這裡不是有附上就業證明嗎！」<br>（氣！）<br><br/></p><p>「台湾人要附上台胞证啊，你这张是台湾居民往来大陆通行证」<br>「這就是台胞證啊，台胞證只是簡稱啦！」<br>「你看我们系统，没有这张证可以选，就只有台胞证可以选」<br>（我要抓狂了！）<br><br/></p><p>「我还是不确定能不能给你办，你去问我们主任吧，他的办公室在 balbal…」<br>（爆炸！）</p><p>幸好該處的主管看起來不是一個難商量的人，很快就同意讓我辦理體檢。<br><br/></p><h2 id="地雷-2-沒有明文規範，怎麼辦？都是看有權力的人怎麼說">地雷 2: 沒有明文規範，怎麼辦？都是看有權力的人怎麼說</h2><blockquote><p><strong>不像台灣大小事都有明文規範、條文優先於慣例。中國大陸即使是簡單的公務流程，也存在非常多模糊地帶。第一線辦理人員的素質通常很差，就只是個文書機器人，並不了解負責業務的相關規定，一定要請示過主管才知道怎麼做。</strong></p></blockquote><hr><p>「國際旅行衛生保健中心」聽起來就是很高大上的地方，那體檢很嚴謹摟？錯！除了抽血、身高體重、心電圖這些檢驗項目以外，不是還有一項＂精神病＂要檢查嗎？這不是驗血可以驗得出來的吧？但從頭到尾沒有醫生為我問診過。<br><br/></p><p>「醫生呢？不是還有醫生問診嗎？」<br>「医生去吃午饭了」<br>但我早上 10:30 就來了，沒看醫生出現過。<br><br/></p><p>「那怎麼辦？剩下的檢驗項目要等到哪時候？」<br>「前面不是有问诊了吗？」<br>「不是，那個是護士小姐給我做色盲檢查和心電圖」<br>「外面轉角有家店可以打印照片，等你打印回来看看医生吃完了没」<br><br/></p><p>結果是：我印完照片，也沒看到醫生，他們說這樣就可以了。</p><p>看起來是因為保健中心本身的怠惰，就順便給你方便。但如果你是要看這份體檢報告的用人公司呢？你會不會怕？</p><br/><h2 id="地雷-3-看起來乾淨整齊高檔次的機關，做事不一定就嚴謹">地雷 3: 看起來乾淨整齊高檔次的機關，做事不一定就嚴謹</h2><blockquote><p><strong>相比於受歐美影響大的台灣、日本來說，中國大陸是一個高度崇尚外表的社會，內在與外在的差距，往往大到台灣人難以想像，通常是內在極大的落後於外在。「外表精緻華麗，內心缺乏靈魂」是中國大陸一線大城市經常給我的感受，「人不可貌相」在中國大陸更貼切。</strong></p></blockquote><hr><p>因為搭車來單程就要兩個小時，實在是太遠，我就依照<a href="http://www.gdwbzx.com/hdjl/wyd/201603/t20160331_106357.html">官網規定</a>（如下圖）請他們用 EMS 寄件給我。<br><img src="/content/images/%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%BA%BA%E5%93%A1%E5%B0%B1%E6%A5%AD%E9%AB%94%E6%AA%A2/%E6%8A%A5%E5%91%8A%E5%8F%AF%E4%BB%A5%E9%82%AE%E5%AF%84%E5%90%97.jpg" alt=""></p><p>然而櫃台大媽說「没有寄，我们这里没有帮人邮寄的，你得自己来取」，即使拿出了官網的說明，大媽依然像是看不懂文字一樣的不為所動。最後，我只好認命地再跑一趟。</p><br/><h2 id="地雷-4-即使有明文規範，承辦人員也不鳥，怎麼辦都是看他爽">地雷 4: 即使有明文規範，承辦人員也不鳥，怎麼辦都是看他爽</h2><blockquote><p><strong>中國大陸各行各業普遍缺乏法治、契約、敬業的觀念，就算是公務機關也一樣，大部分大陸人從小到大吃虧習慣，都已經順從這一套了，所以很少有人會去申訴，因此這些惡習就更加穩固。通常外商或港、台資企業會稍微好一點。</strong></p></blockquote><hr><p>過了一周，我就來取件。<br><img src="/content/images/%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%BA%BA%E5%93%A1%E5%B0%B1%E6%A5%AD%E9%AB%94%E6%AA%A2/IMG_20180806_145146.jpg" alt=""></p><p>因為前面踩過的地雷實在太多，我特別要求當場拆開信封看，確認是不是真的有霍亂、黃熱、鼠疫、痲瘋、性病、開放性肺結核、愛滋、精神病這八項檢驗結果。還好這個要求沒有被為難，大媽這次居然意外的盡責，提醒我說，信封是有騎縫章的，拆開檢查完以後要再給他們重新封一次，否則其他機關不會收件。</p><hr><p>好不容易折騰完這一番，我又搭了兩個小時的車回去公司。將體檢報告拿交給人資以後，下午卻傳來了這樣的訊息（如下圖）。</p><p><img src="/content/images/%E6%B8%AF%E6%BE%B3%E5%8F%B0%E4%BA%BA%E5%93%A1%E5%B0%B1%E6%A5%AD%E9%AB%94%E6%AA%A2/%E8%A6%8B%E8%AD%89%E6%AD%B7%E5%8F%B2.jpg" alt=""></p><p>人事告訴我，當天新政策已經實施了，港澳台籍人士到中國大陸就業，再也不用辦理就業證了，所以相關的特別體檢規定也隨之作廢。花了［2小時車程＊4次＋挨一針］奔波來的文件，通通用不到了。幸虧人事下了「見證歷史」這個註腳，才讓這些努力沒有徹底付諸東流的白費感。</p><br/><h2 id="地雷-5-政策詭譎多變">地雷 5: 政策詭譎多變</h2><blockquote><p><strong>這有時候是好處、也是壞處。往往可以看到整治、改進推行得很快。但規定的多變，也讓中國大陸的長期投資難免投鼠忌器，不論人或企業都比台灣浮躁、比較偏好短期回收的投資。</strong></p></blockquote><p>以上種種坑，我絕對不是第一個遇到。即使有了經驗，今後也不會是最後一次遇到（除非現在打包回台）。果真是「物離鄉貴，人離鄉賤」啊！</p><hr><p>全文刊登於「<a href="https://crossing.cw.com.tw/blogTopic.action?id=1079&amp;nid=10679">換日線</a>」，致謝編輯張翔一給予修改意見。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;這是一個「踏破鐵鞋辦文件，得來全不費工夫」的故事。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上班到一半的時候，剛去幫我辦「港澳台人員就業證」的人資，突然拿了一份讓我傻眼的公文來。公文內容的重點是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;港澳台人員若要在當地就業，必</summary>
      
    
    
    
    
    <category term="大陸" scheme="https://mosdeo.github.io/tags/%E5%A4%A7%E9%99%B8/"/>
    
    <category term="管理" scheme="https://mosdeo.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
    <category term="批判" scheme="https://mosdeo.github.io/tags/%E6%89%B9%E5%88%A4/"/>
    
  </entry>
  
</feed>
